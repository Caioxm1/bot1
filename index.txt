const crypto = require('crypto')
globalThis.crypto = crypto.webcrypto;
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason } = require('@whiskeysockets/baileys');
const axios = require('axios');
const express = require('express');
const { ChartJSNodeCanvas } = require('chartjs-node-canvas');
const WebSocket = require('ws');
const app = express();
const NIVEL_APRENDIZADO = {
  BASICO: { meta: 70, revisao: 24 }, // Horas entre revis√µes
  INTERMEDIARIO: { meta: 80, revisao: 48 },
  AVANCADO: { meta: 90, revisao: 72 }
};

app.use(express.json());

const OPENROUTER_API_KEY = "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";
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzfdPVe8l1OnXHw6i6kkk3NV9gTt2-oC0sE2WLDuN6InBU1K5kopMyT07kElsCulrNY/exec';
const GRUPOS_PERMITIDOS = [
  '120363420675161205@g.us' // Grupo original
];
const USUARIOS_AUTORIZADOS = [
  '5521975874116@s.whatsapp.net', // N1
  '5521976919619@s.whatsapp.net' // N2
];
const chartJSNodeCanvas = new ChartJSNodeCanvas({
  width: 800,
  height: 600,
  backgroundColour: 'white'
});

const wss = new WebSocket.Server({ port: 8080 });

let ultimoComandoProcessado = null;

const niveis = {
  iniciante: [],
  intermediario: [],
  avancado: []
};

let progressoUsuario = {
  nivelAtual: 'iniciante',
  respostasCorretas: 0,
  totalPerguntas: 0,
  totalPerguntasDoNivel: 0
};

let estadoConversa = {};

// Adicionar um controle para evitar processamentos duplicados
let processandoRespostaFlag = false;
let envioExplicacaoEmAndamento = {};

// Fun√ß√£o para log detalhado
function logMensagem(msg, tipo = 'recebida') {
  const dataHora = new Date().toISOString();
  const remetente = msg?.pushName || 'Desconhecido';
  const texto = msg.message?.conversation || '(m√≠dia ou mensagem sem texto)';
  const chatId = msg.key.remoteJid;
  
  console.log(`[${dataHora}] Mensagem ${tipo}:`);
  console.log(`De: ${remetente} (${chatId})`);
  console.log(`Texto: ${texto}`);
  console.log('---');
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function enviarMensagemComDelay(jid, conteudo, isGroup = false) {
  if (!conteudo?.text) {
    console.error("‚ö†Ô∏è Tentativa de enviar mensagem sem texto!");
    conteudo = { text: "‚ùå Ocorreu um erro inesperado" }; // Fallback
  }
  await delay(1000);
  if (isGroup) {
    await sock.sendMessage(jid, conteudo, { quoted: null });
  } else {
    await sock.sendMessage(jid, conteudo);
  }
}

let ultimoComandoUsuario = { jid: null, timestamp: 0 }; // Renomeada para mais clareza

async function processarComando(jid, texto) {
  // Ignora mensagens do pr√≥prio bot
  if (texto.includes("‚è≥ Aguarde") || texto.includes("‚ùå Erro")) {
    return null;
  }

  const agora = Date.now();
  if (ultimoComandoUsuario.jid === jid && (agora - ultimoComandoUsuario.timestamp) < 2000) {
    return "‚è≥ Aguarde 2 segundos antes de outro comando.";
  }
  
  ultimoComandoUsuario = { jid, timestamp: agora };
  return null;
}

// Lista de comandos para o comando "ajuda"
const LISTA_DE_COMANDOS = `
üìö *Lista de Comandos de Estudo* üìö

üìÖ *Agendamento*
- estudar [mat√©ria]: Inicia/retoma estudos de uma mat√©ria
- agendar [mat√©ria] [data] [hora]: Agenda um bloco de estudo
- cronograma: Mostra sua agenda de estudos
- concluir [id]: Marca sess√£o como conclu√≠da

üìù *Anota√ß√µes*
- anotar [mat√©ria] [texto]: Adiciona uma anota√ß√£o
- anota√ß√µes [mat√©ria]: Lista anota√ß√µes de uma mat√©ria
- buscar [termo]: Busca em todas anota√ß√µes

üîÑ *Revis√£o*
- flashcard [mat√©ria]: Mostra um flashcard para revis√£o
- responder [resposta]: Responde o flashcard atual
- estat√≠sticas: Mostra desempenho nos flashcards

üìä *Acompanhamento*
- metas: Mostra suas metas de estudo
- definir meta [mat√©ria] [horas]: Define meta semanal
- progresso: Mostra progresso nas mat√©rias

üìã *Avalia√ß√µes*
- prova [mat√©ria] [data]: Agenda uma prova
- simulado [tipo] [data]: Agenda simulado
- resultados: Mostra desempenho em avalia√ß√µes

üîß *Ajuda*
- ajuda: Mostra esta lista de comandos
`;

// Adicionando logs mais detalhados para erros
function logErroDetalhado(erro) {
  console.error("‚ùå Erro Detalhado:", erro.message);
  if (erro.response) {
    console.error("Status:", erro.response.status);
    console.error("Dados da resposta:", erro.response.data);
  }
  console.error("Stack:", erro.stack);
}

// Fun√ß√£o auxiliar para chamar a API OpenRouter com retries e tratamento de erro
async function chamarOpenRouter(prompt, isJsonOutput = false) {
  console.log(`ü§ñ Chamando OpenRouter. JSON esperado: ${isJsonOutput}`);
  let tentativas = 0;
  const maxTentativas = 3; // Reduzido para 3 tentativas

  while (tentativas < maxTentativas) {
    try {
      console.time("Tempo de resposta OpenRouter");
      const requestBody = {
        model: 'deepseek/deepseek-chat-v3-0324:free',
        messages: [{ role: 'user', content: prompt }],
      };
      if (isJsonOutput) {
        requestBody.response_format = { type: "json_object" };
      }

      const resposta = await axios.post(
        'https://openrouter.ai/api/v1/chat/completions',
        requestBody,
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
            'HTTP-Referer': 'http://localhost',
            'X-Title': 'Bot de Estudos'
          },
          timeout: 15000 // Aumentado para 15 segundos para gera√ß√£o de conte√∫do
        }
      );
      console.timeEnd("Tempo de resposta OpenRouter");

      if (!resposta.data?.choices?.[0]?.message?.content) {
        throw new Error("Resposta da API em formato inv√°lido ou vazia.");
      }

      console.log("üí¨ Resposta bruta da OpenRouter:", resposta.data.choices[0].message.content);
      return resposta.data.choices[0].message.content;

    } catch (error) {
      console.timeEnd("Tempo de resposta OpenRouter");
      tentativas++;
      logErroDetalhado(error); // Usa a fun√ß√£o de log detalhado existente

      if (error.response?.status === 429) {
        console.error("üö´ Limite de requisi√ß√µes excedido na OpenRouter.");
        throw new Error("Limite de requisi√ß√µes excedido. Tente novamente mais tarde."); // Relan√ßa o erro
      }
      
      if (tentativas >= maxTentativas) {
         console.error(`üö´ Falha ao chamar OpenRouter ap√≥s ${maxTentativas} tentativas.`);
         throw new Error("Falha ao gerar conte√∫do ap√≥s m√∫ltiplas tentativas."); // Relan√ßa o erro
      }

      console.log(`‚è≥ Tentando novamente em 2 segundos (Tentativa ${tentativas})...`);
      await delay(2000);
    }
  }
}

async function criarMateria(nome) {
  console.log("üìö Criando nova mat√©ria:", nome);
  try {
    const nomeLimpo = nome.replace(/[^\w\s]/g, '').trim();
    const response = await chamarOpenRouter(`Crie um plano de ensino em JSON para "${nomeLimpo}" com 3 n√≠veis. Inclua t√≥picos e recursos.`, true);

    // Verifica√ß√£o rigorosa da resposta
    if (!response || response.status === 'error') {
      throw new Error(response?.message || "Resposta inv√°lida da API");
    }

    return response.message || "‚úÖ Mat√©ria criada com sucesso!"; // Fallback
  } catch (error) {
    console.error("‚ùå Erro ao criar mat√©ria:", error);
    return error.message || "‚ùå Erro desconhecido ao criar mat√©ria"; // Garante string
  }
}

async function agendarSessao(materia, data, hora, duracao = "", topico = "") {
  return await chamarOpenRouter(`Agende um bloco de estudo para "${materia}" no dia "${data}" √†s "${hora}". Se necess√°rio, especifique um t√≥pico ou dura√ß√£o adicional.`, true);
}

async function adicionarAnotacao(materia, topico, texto, tags = "") {
  return await chamarOpenRouter(`Adicione uma anota√ß√£o sobre "${materia}" no t√≥pico "${topico}". Anote o texto: "${texto}". Se necess√°rio, adicione tags: "${tags}".`, true);
}

async function criarFlashcard(materia, pergunta, resposta) {
  return await chamarOpenRouter(`Crie um flashcard para "${materia}" com a pergunta: "${pergunta}" e a resposta: "${resposta}".`, true);
}

async function definirMeta(materia, horas, data_limite) {
  return await chamarOpenRouter(`Defina uma meta de estudo para "${materia}" de ${horas} horas at√© "${data_limite}".`, true);
}

async function registrarAvaliacao(materia, tipo, data, resultado, topicos) {
  return await chamarOpenRouter(`Registre o resultado da avalia√ß√£o "${tipo}" para "${materia}" no dia "${data}". O resultado foi "${resultado}". Se necess√°rio, adicione coment√°rios sobre os t√≥picos: "${topicos}".`, true);
}

async function atualizarProgresso(materia_id, progresso) {
  return await chamarOpenRouter(`Atualize o progresso de "${materia_id}" para ${progresso}%.`, true);
}

async function alterarStatus(materia_id, status) {
  return await chamarOpenRouter(`Altere o status de "${materia_id}" para "${status}".`, true);
}

async function obterInfoMateria(materia_id) {
  return await chamarOpenRouter(`Forne√ßa informa√ß√µes sobre "${materia_id}".`, true);
}

// Fun√ß√£o de fallback para interpreta√ß√£o manual
function interpretarMensagemManual(texto) {
  console.log("\nüîÑ Usando interpreta√ß√£o manual para:", texto);
  
  const textoLower = texto.toLowerCase();
  
  // Padr√µes para detec√ß√£o de comandos
  if (textoLower.includes("estudar") || textoLower.includes("quero estudar") || textoLower.includes("vou estudar") || textoLower.includes("iniciar")) {
    // Extrai a mat√©ria ap√≥s a palavra "estudar" ou varia√ß√µes
    const materia = texto.split(/estudar|quero estudar|vou estudar|iniciar/i)[1]?.trim();
    if (materia) {
      console.log("üìö Mat√©ria extra√≠da:", materia);
      // Inicia o processo de cria√ß√£o de um plano de ensino
      return {
        comando: "estudar",
        parametros: { materia }
      };
    }
  }
  
  console.log("‚ö†Ô∏è Nenhum comando reconhecido");
  return null;
}

// Adicionar esta fun√ß√£o para detectar mensagens de sistema
function isMensagemSistema(texto) {
  // Padr√µes que identificam mensagens do sistema
  const padroesDoSistema = [
    /^progresso atual:/i,
    /^voc√™ atingiu [0-9.]+% de acertos/i,
    /^vamos recome√ßar as perguntas/i,
    /^parab√©ns!/i,
    /^‚ö†Ô∏è n√£o entendi qual comando/i,
    /^correto!/i,
    /^incorreto\./i
  ];
  
  return padroesDoSistema.some(padrao => padrao.test(texto));
}

// Modifique a verifica√ß√£o na fun√ß√£o pareceSerComandoEstudo para excluir mensagens de sistema
function pareceSerComandoEstudo(texto) {
  // Se for uma mensagem do sistema, retornar false imediatamente
  if (isMensagemSistema(texto)) {
    console.log("[pareceSerComandoEstudo] Mensagem do sistema detectada, ignorando como comando.");
    return false;
  }

  const palavrasChave = [
    "estudar", "aprender", "mat√©ria", "agendar", "cronograma",
    "anotar", "anota√ß√µes", "flashcard", "responder", "prova",
    "simulado", "meta", "metas", "progresso", "revisar",
    "concluir", "buscar", "estat√≠sticas", "resultados",
    "iniciar",
    "ensinar"
  ];
  
  const textoLower = texto.toLowerCase();
  
  // Verifica se cont√©m alguma palavra-chave
  const temPalavraChave = palavrasChave.some(palavra => 
    textoLower.includes(palavra.toLowerCase())
  );
  
  // Verifica se come√ßa com "estudar" ou varia√ß√µes (incluindo "ensinar" agora implicitamente via palavrasChave)
  const comecaComComando = /^(estudar|quero estudar|vou estudar|iniciar|ensinar)/i.test(textoLower);

  // Logs internos para depura√ß√£o
  console.log(`[pareceSerComandoEstudo] Texto: "${textoLower}"`);
  console.log(`[pareceSerComandoEstudo] Tem Palavra Chave? ${temPalavraChave}`);
  console.log(`[pareceSerComandoEstudo] Come√ßa com Comando? ${comecaComComando}`);
  
  const resultado = temPalavraChave || comecaComComando;
  console.log(`[pareceSerComandoEstudo] Resultado: ${resultado}`);
  return resultado;
}

// Fun√ß√£o principal do bot
let sock = null;

async function iniciarConexaoWhatsApp() {
  console.log('Iniciando conex√£o WhatsApp...');
  const { state, saveCreds } = await useMultiFileAuthState('auth_info');
  console.log('Estado da autentica√ß√£o:', state ? 'OK' : 'FALHA');
  
  sock = makeWASocket({
    auth: state,
    printQRInTerminal: true,
    browser: ['Bot de Estudos', 'Chrome', '115.0.0.0'],
    syncFullHistory: false
  });

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', (update) => {
    const { connection, lastDisconnect } = update;
    
    if (connection === 'close') {
      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
      console.log('Conex√£o fechada devido a ', lastDisconnect.error, ', reconectando:', shouldReconnect);
      if (shouldReconnect) {
        setTimeout(() => {
          console.log('Tentando reconectar...');
          iniciarConexaoWhatsApp();
        }, 3000);
      }
    } else if (connection === 'open') {
      console.log('‚úÖ Conex√£o estabelecida com sucesso!');
    }
  });

  sock.ev.on('messages.upsert', async ({ messages }) => {
    const msg = messages[0];
    if (!msg?.message || !msg.key?.remoteJid) return;

    // Extrair o texto da mensagem para verifica√ß√£o
    const texto = msg.message.conversation?.trim() || msg.message.extendedTextMessage?.text?.trim() || "";

    // IMPORTANTE: L√≥gica revisada para permitir mensagens enviadas pelo mesmo n√∫mero
    // 1. Verifica se a mensagem cont√©m padr√µes t√≠picos de mensagens do bot
    const isBotResponse = 
      (texto.startsWith('‚ùì') || 
       texto.startsWith('üìñ') ||
       texto.startsWith('Incorreto') ||
       texto.startsWith('Correto!') ||
       texto.startsWith('Progresso atual:') ||
       texto.startsWith('Voc√™ atingiu'));

    // 2. Se for do pr√≥prio n√∫mero mas n√£o parecer uma mensagem autom√°tica do bot,
    //    provavelmente √© uma mensagem manual do usu√°rio que devemos processar
    if (msg.key.fromMe && !isBotResponse && !isMensagemSistema(texto)) {
      // Esta √© possivelmente uma mensagem manual do usu√°rio usando o mesmo n√∫mero
      console.log('üì± Mensagem enviada manualmente do mesmo n√∫mero do bot. Processando normalmente.');
    } 
    // 3. Se for uma mensagem autom√°tica do bot ou mensagem de sistema, ignoramos
    else if (msg.key.fromMe || isMensagemSistema(texto)) {
      console.log('‚ö†Ô∏è Mensagem autom√°tica do bot ou mensagem de sistema. Ignorando para evitar loops.');
      return;
    }
    
    // Permite que comandos manuais do usu√°rio sejam processados
    const isUserCommand = pareceSerComandoEstudo(texto);

    // Verificar se o usu√°rio tem um estado de conversa ativo
    const temEstadoAtivo = estadoConversa[msg.key.remoteJid] !== undefined;
    
    console.log('\n=== NOVA MENSAGEM RECEBIDA ===');
    console.log('üì± Remetente:', msg.pushName || 'Desconhecido');
    console.log('üîë Chat ID:', msg.key.remoteJid);
    console.log('üîë Participant:', msg.key.participant);
    console.log('üîë fromMe:', msg.key.fromMe);
    console.log('üí¨ Texto:', texto);
    console.log('üîë Estado de conversa ativo:', temEstadoAtivo);
    
    // Ignora mensagens de status
    if (msg.key.remoteJid === 'status@broadcast') {
      console.log('‚ö†Ô∏è Mensagem de status ignorada');
      return;
    }

    // Adiciona logs de depura√ß√£o para verificar o identificador do usu√°rio
    console.log('üîç Verificando usu√°rio JID:', msg.key.remoteJid);
    console.log('üîç Usu√°rios autorizados:', USUARIOS_AUTORIZADOS);

    const isGrupoValido = GRUPOS_PERMITIDOS.includes(msg.key.remoteJid);
    const isUsuarioValido = USUARIOS_AUTORIZADOS.includes(msg.key.remoteJid);
      
    console.log('üîí Verifica√ß√µes Iniciais:');
    console.log('- Grupo v√°lido:', isGrupoValido);
    console.log('- Usu√°rio v√°lido:', isUsuarioValido);
      
    if (!isGrupoValido && !isUsuarioValido) {
      console.log('‚ùå Chat/Usu√°rio n√£o autorizado:', msg.key.remoteJid);
      return;
    }
    
    console.log('‚úÖ Verifica√ß√µes de autoriza√ß√£o e bot passadas.');
    
    // Verifica se √© uma resposta a uma pergunta anterior (conversa ativa)
    if (temEstadoAtivo && !isUserCommand) {
      console.log('üß† Resposta a pergunta detectada. Processando resposta...');
      await processarResposta(msg.key.remoteJid, texto, isGrupoValido);
      return;
    }
    
    // Resto da l√≥gica de processamento
    const textoLower = texto.toLowerCase();
    console.log('üö¶ Texto em min√∫sculas:', textoLower);

    if (textoLower === 'ajuda') {
      console.log('üìö Comando "ajuda" detectado. Enviando lista...');
      await enviarMensagemComDelay(msg.key.remoteJid, { text: LISTA_DE_COMANDOS }, isGrupoValido);
      console.log('üìö Lista de comandos enviada. Saindo do processamento.');
      return;
    }

    console.log('üö¶ Comando n√£o √© "ajuda". Prosseguindo...');
    console.log('üß† Verificando se √© comando de estudo...');

    if (pareceSerComandoEstudo(texto)) {
      console.log('üìö Processando comando de estudo:', texto);
      
      // Interpreta√ß√£o do comando (SIMPLIFICADA - pode precisar refinar)
      let comando = null;
      let materia = null;
      if (textoLower.startsWith('estudar') || textoLower.startsWith('ensinar') || textoLower.startsWith('iniciar')) {
          comando = 'estudar';
          // Extrai a mat√©ria ap√≥s o comando
          materia = texto.split(/^(?:estudar|ensinar|iniciar)\s+/i)[1]?.trim(); 
      } else if (textoLower.startsWith('criar plano')) { // Exemplo de outro comando
          comando = 'criar_plano_ensino';
          materia = texto.split(/^(?:criar plano)\s+/i)[1]?.trim();
      }
      // Adicionar mais l√≥gicas if/else if para outros comandos (agendar, anotar, etc.)

      if (!comando || !materia) {
           console.log('‚ö†Ô∏è N√£o foi poss√≠vel extrair comando/mat√©ria v√°lidos da mensagem:', texto);
           await enviarMensagemComDelay(msg.key.remoteJid, { text: "‚ö†Ô∏è N√£o entendi qual comando ou mat√©ria voc√™ quer. Ex: 'ensinar f√≠sica qu√¢ntica'" }, isGrupoValido);
        return;
      }

      console.log(`üí° Comando interpretado: ${comando}, Mat√©ria: ${materia}`);

        let response;
        try {
        console.log(`‚ö° Executando comando: ${comando}`);
        switch (comando) {
          case 'estudar': // 'ensinar' e 'iniciar' tamb√©m caem aqui
            estadoConversa[msg.key.remoteJid] = { nivelAtual: 'iniciante', indicePergunta: 0 };
            await ensinarMateria(materia, msg.key.remoteJid, isGrupoValido);
            return;
          case 'criar_plano_ensino':
            response = await criarPlanoEnsino(materia);
              break;
          // ... Adicionar outros cases conforme necess√°rio ...
            default:
            response = "‚ùå Comando n√£o reconhecido internamente. Use 'ajuda'.";
        }

        // Valida√ß√£o e formata√ß√£o da resposta (l√≥gica existente)
        if (typeof response !== 'string') {
          console.error("Resposta inv√°lida para envio:", response);
          if (typeof response === 'object' && response !== null) {
            if (response.explicacao && response.perguntas) {
              let textoResposta = `üìñ ${response.explicacao}\n\n`;
              textoResposta += `‚ùì Perguntas N√≠vel ${progressoUsuario.nivelAtual}:\n`;
              response.perguntas.forEach((p, index) => {
                textoResposta += `${index + 1}. ${p.pergunta}\n`;
              });
              response = textoResposta;
            } else {
              response = "‚ùå Erro: Resposta interna em formato inesperado.";
            }
          } else {
            response = "‚ùå Erro inesperado no processamento do comando.";
          }
        }

        console.log('üì§ Enviando resposta formatada:', response);
        await enviarMensagemComDelay(msg.key.remoteJid, { text: response }, isGrupoValido);

      } catch (error) {
        console.error('‚ùå Erro ao processar comando espec√≠fico:', error);
        // Envia a mensagem de erro da exce√ß√£o, se houver, caso contr√°rio, uma gen√©rica
        const errorMsg = error.message || "Ocorreu um erro ao processar seu comando. Tente novamente.";
        await enviarMensagemComDelay(msg.key.remoteJid, { 
          text: `‚ùå ${errorMsg}` 
        }, isGrupoValido);
      }

    } else if (temEstadoAtivo) {
      console.log('üîÑ Estado de conversa ativo detectado. Processando resposta...');
      const estado = estadoConversa[msg.key.remoteJid];
      const perguntas = niveis[estado.nivelAtual];
      
      if (!perguntas || perguntas.length === 0) {
        console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
        await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGrupoValido);
        delete estadoConversa[msg.key.remoteJid];
        return;
      }

      // Verifica se j√° respondeu todas as perguntas
      if (estado.indicePergunta >= perguntas.length) {
        console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} j√° foram respondidas`);
        const progresso = verificarProgresso();
        await enviarMensagemComDelay(msg.key.remoteJid, { text: progresso }, isGrupoValido);
        
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        if (progressoUsuario.nivelAtual === estado.nivelAtual) {
          estado.indicePergunta = 0;
          await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGrupoValido);
          await delay(1000);
          await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
        } else {
          // Se avan√ßou, prepara uma nova explica√ß√£o
          const novoNivel = progressoUsuario.nivelAtual;
          try {
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${novoNivel}. Preparando nova explica√ß√£o...` }, isGrupoValido);
            
            const materia = estado.materia;
            const explicacao = await gerarExplicacao(materia, novoNivel);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üìñ ### **${materia} ‚Äì ${novoNivel.toUpperCase()}**\n\n${explicacao}` }, isGrupoValido);
            
            // Atualiza o estado para o novo n√≠vel
            estado.nivelAtual = novoNivel;
            estado.indicePergunta = 0;
            
            // Envia a primeira pergunta do novo n√≠vel
            await delay(2000);
            await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
          } catch (error) {
            console.error(`‚ùå Erro ao avan√ßar para novo n√≠vel:`, error);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${novoNivel}. Por favor, reinicie o estudo.` }, isGrupoValido);
          }
        }
        return;
      }

      const perguntaAtual = perguntas[estado.indicePergunta];
      if (!perguntaAtual) {
        console.error('Pergunta atual n√£o encontrada para:', msg.key.remoteJid);
        return;
      }
      
      console.log('üß† Verificando resposta para:', perguntaAtual.pergunta);
      console.log('üß† Resposta do usu√°rio:', texto);
      console.log('üß† Resposta correta:', perguntaAtual.respostaCorreta);
      
      const resposta = verificarResposta(perguntaAtual, texto);
      await enviarMensagemComDelay(msg.key.remoteJid, { text: resposta }, isGrupoValido);

      // Avan√ßa para a pr√≥xima pergunta independentemente se acertou ou n√£o
      estado.indicePergunta++;
      
      // Verifica se j√° respondeu todas as perguntas do n√≠vel atual para dar o progresso
      // CORRE√á√ÉO: Removendo esta verifica√ß√£o aqui, s√≥ verificar√° quando terminar todas as perguntas
      // O progresso intermedi√°rio ser√° mostrado junto com a pr√≥xima pergunta
      console.log(`üìä Progresso atual: ${progressoUsuario.respostasCorretas}/${progressoUsuario.totalPerguntas} (${(progressoUsuario.respostasCorretas/progressoUsuario.totalPerguntas*100).toFixed(1)}%)`);
      
      // Se ainda tem mais perguntas no n√≠vel atual, envia a pr√≥xima
      if (estado.indicePergunta < perguntas.length) {
        await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
      } else {
        // Se j√° respondeu todas, finaliza o n√≠vel e verifica se pode avan√ßar
        console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} foram respondidas`);
        const progresso = verificarProgresso();
        await enviarMensagemComDelay(msg.key.remoteJid, { text: progresso }, isGrupoValido);
        
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        if (progressoUsuario.nivelAtual === estado.nivelAtual) {
          estado.indicePergunta = 0;
          await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGrupoValido);
          await delay(1000);
          await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
        } else {
          // Se avan√ßou, prepara uma nova explica√ß√£o
          const novoNivel = progressoUsuario.nivelAtual;
          try {
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${novoNivel}. Preparando nova explica√ß√£o...` }, isGrupoValido);
            
            const materia = estado.materia;
            const explicacao = await gerarExplicacao(materia, novoNivel);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üìñ ### **${materia} ‚Äì ${novoNivel.toUpperCase()}**\n\n${explicacao}` }, isGrupoValido);
            
            // Atualiza o estado para o novo n√≠vel
            estado.nivelAtual = novoNivel;
            estado.indicePergunta = 0;
            
            // Envia a primeira pergunta do novo n√≠vel
            await delay(2000);
            await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
          } catch (error) {
            console.error(`‚ùå Erro ao avan√ßar para novo n√≠vel:`, error);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${novoNivel}. Por favor, reinicie o estudo.` }, isGrupoValido);
          }
        }
      }
    } else {
      console.log('‚ö†Ô∏è Comando n√£o parece ser de estudo e n√£o h√° estado de conversa ativo:', texto);
    }
  });
}

// Fun√ß√£o para criar um plano de ensino
async function criarPlanoEnsino(materia) {
  try {
    // Chamar LLM para gerar plano (exemplo com DeepSeek)
    const prompt = `Crie um plano de ensino em JSON para "${materia}" com 3 n√≠veis. Inclua t√≥picos e recursos.`;
    let respostaLLM;
    let tentativas = 0;
    const maxTentativas = 5; // Aumentar o n√∫mero de tentativas

    while (tentativas < maxTentativas) {
      try {
        console.time("Tempo de resposta da API"); // Inicia o cron√¥metro para medir o tempo de resposta
        respostaLLM = await axios.post(
          'https://openrouter.ai/api/v1/chat/completions',
          {
            model: 'deepseek/deepseek-chat-v3-0324:free',
            response_format: { type: "json_object" }, // Solicita resposta JSON
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
          },
          {
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
              'HTTP-Referer': 'http://localhost',
              'X-Title': 'Bot de Estudos'
            },
            timeout: 10000 // Mant√©m o timeout de 10 segundos
          }
        );
        console.timeEnd("Tempo de resposta da API"); // Finaliza o cron√¥metro e exibe o tempo de resposta
        break; // Sai do loop se a solicita√ß√£o for bem-sucedida
      } catch (error) {
        console.timeEnd("Tempo de resposta da API"); // Finaliza o cron√¥metro em caso de erro
        tentativas++;
        console.error(`‚ùå Erro ao chamar API (tentativa ${tentativas}):`, error);
        if (error.response?.status === 429) {
          console.error("‚ùå Limite de requisi√ß√µes excedido. Tente novamente mais tarde.");
          return "‚ùå Limite de requisi√ß√µes excedido. Tente novamente mais tarde.";
        }
        if (tentativas >= maxTentativas || (error.response?.status !== 502 && !error.response?.data?.choices?.[0]?.error?.metadata?.raw?.retryable)) {
          console.log("üîÑ Usando interpreta√ß√£o manual para continuar o processamento.");
          return criarPlanoBasico(materia); // Usa interpreta√ß√£o manual para criar um plano b√°sico
        }
        await delay(2000); // Espera 2 segundos antes de tentar novamente
      }
    }

    // Adiciona log para capturar a resposta completa
    console.log("üì• Resposta completa da LLM:", JSON.stringify(respostaLLM.data, null, 2));
    console.log("üì• Tipo de conte√∫do:", respostaLLM.headers['content-type']);

    // Verifica se a resposta √© do tipo esperado
    if (!respostaLLM.headers['content-type'].includes('application/json')) {
      console.error("‚ùå Resposta n√£o √© JSON:", respostaLLM.data);
      return criarPlanoBasico(materia); // Retorna plano b√°sico se a resposta n√£o for JSON
    }

    // Tenta extrair e analisar a parte JSON da resposta
    let plano;
    try {
      const messageContent = respostaLLM.data.choices[0].message.content;
      console.log("üì• Conte√∫do da mensagem:", messageContent);
      const jsonMatch = messageContent.match(/\{[^]*\}/);
      if (!jsonMatch) {
        console.error("‚ùå JSON n√£o encontrado na resposta:", messageContent);
        return criarPlanoBasico(materia); // Retorna plano b√°sico se JSON n√£o for encontrado
      }
      plano = JSON.parse(jsonMatch[0]);
    } catch (jsonError) {
      console.error("‚ùå Erro ao analisar JSON:", jsonError);
      return criarPlanoBasico(materia); // Retorna plano b√°sico se houver erro ao analisar JSON
    }
    
    // Verifica se o plano possui n√≠veis e t√≥picos
    if (!plano.plano_ensino || !plano.plano_ensino.niveis || plano.plano_ensino.niveis.length === 0) {
      return criarPlanoBasico(materia); // Retorna plano b√°sico se a estrutura estiver incompleta
    }

    for (const nivel of plano.plano_ensino.niveis) {
      if (!nivel.topicos || nivel.topicos.length === 0) {
        return criarPlanoBasico(materia); // Retorna plano b√°sico se algum n√≠vel n√£o tiver t√≥picos
      }
    }

    // Registrar no Google Sheets
    const response = await chamarOpenRouter(`Registre o plano de ensino para "${materia}" com os dados: ${JSON.stringify(plano)} e o prazo: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()}`, true);

    return `üìò Plano criado! Primeiro t√≥pico: ${plano.plano_ensino.niveis[0].topicos[0]}
Recursos: ${plano.plano_ensino.niveis[0].recursos.join(", ")}`;
  } catch (error) {
    return criarPlanoBasico(materia); // Retorna plano b√°sico em caso de erro geral
  }
}

// Fun√ß√£o para criar um plano b√°sico quando a API falhar
function criarPlanoBasico(materia) {
  console.log("üîÑ Criando plano b√°sico para:", materia);
  return `üìò Plano b√°sico criado para ${materia}. Primeiro t√≥pico: Introdu√ß√£o ao ${materia}`;
}

async function agendarRevisao(materiaId, t√≥pico) {
  const agenda = planilha.getSheetByName("Hist√≥rico");
  agenda.appendRow([
    materiaId,
    `Revis√£o programada: ${t√≥pico}`,
    new Date(Date.now() + NIVEL_APRENDIZADO.BASICO.revisao * 60 * 60 * 1000)
  ]);
}

async function buscarProximoT√≥pico(materiaId) {
  const response = await chamarOpenRouter(`Forne√ßa o pr√≥ximo t√≥pico para "${materiaId}"`, true);
  return response.data;
}

// Fun√ß√£o para gerar um identificador √∫nico
function gerarIdUnico() {
  return 'id-' + Math.random().toString(36).substr(2, 9);
}

async function ensinarMateria(materia, jid, isGroup) {
  console.log(`üìö Iniciando processo de ensinar: ${materia}`);
  if (!materia || materia.trim() === "") {
      return "‚ùå Por favor, especifique a mat√©ria que voc√™ quer aprender. Ex: ensinar hist√≥ria do Brasil";
  }
  
  try {
    // Obter o n√≠vel atual do usu√°rio (ou iniciar como iniciante)
    const nivelAtual = estadoConversa[jid]?.nivelAtual || 'iniciante';
    console.log(`üìä N√≠vel atual do usu√°rio: ${nivelAtual}`);
    
    // Gerar explica√ß√£o apropriada para o n√≠vel atual
    const explicacao = await gerarExplicacao(materia, nivelAtual);
    console.log(`‚úÖ Explica√ß√£o gerada para o n√≠vel: ${nivelAtual}`);
    
    // Gerar perguntas baseadas na explica√ß√£o para o n√≠vel atual
    let perguntasNivel;
    try {
      perguntasNivel = await gerarPerguntas(materia, explicacao, nivelAtual);
      console.log(`‚úÖ Perguntas geradas para o n√≠vel: ${nivelAtual}`);
    } catch (error) {
      console.error(`‚ùå Erro ao gerar perguntas. Usando placeholders:`, error);
      perguntasNivel = await gerarPerguntasPlaceholder(materia, nivelAtual);
    }
    
    // Armazenar perguntas no n√≠vel correspondente
    niveis[nivelAtual] = perguntasNivel;
    
    // Resetar contadores de progresso no in√≠cio do estudo
    progressoUsuario = {
      nivelAtual: nivelAtual,
      respostasCorretas: 0,
      totalPerguntas: 0,
      totalPerguntasDoNivel: perguntasNivel.length
    };
    
    // Inicializar ou atualizar o estado da conversa
    estadoConversa[jid] = { 
      nivelAtual: nivelAtual, 
      indicePergunta: 0,
      materia: materia,
      continuando: true // Marca que esta sess√£o √© uma continua√ß√£o
    };
    
    // Enviar explica√ß√£o e perguntas para o usu√°rio
    let response = `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}\n\n‚ùì Perguntas (N√≠vel ${nivelAtual}):\n`;
    perguntasNivel.forEach((p, index) => {
      response += `${index + 1}. ${p.pergunta}\n`;
    });

    await enviarMensagemComDelay(jid, { text: response }, isGroup);
    console.log(`üì§ Enviada explica√ß√£o e perguntas para o n√≠vel: ${nivelAtual}`);

    // Se estamos iniciando um novo estudo, gerar perguntas para os outros n√≠veis tamb√©m
    // para t√™-las prontas quando o usu√°rio avan√ßar
    if (nivelAtual === 'iniciante' && (!estadoConversa[jid] || !estadoConversa[jid].continuando)) {
      console.log(`üîÑ Gerando perguntas para n√≠veis futuros em segundo plano...`);
      
      // Gerar perguntas para intermedi√°rio (em background)
      gerarExplicacao(materia, 'intermediario').then(explicIntermediario => {
        gerarPerguntas(materia, explicIntermediario, 'intermediario').then(perguntasIntermediario => {
          niveis.intermediario = perguntasIntermediario;
          console.log(`‚úÖ Perguntas para n√≠vel intermedi√°rio armazenadas em background.`);
        }).catch(error => {
          console.error(`‚ùå Erro ao gerar perguntas intermedi√°rias em background:`, error);
          gerarPerguntasPlaceholder(materia, 'intermediario').then(placeholders => {
            niveis.intermediario = placeholders;
          });
        });
      }).catch(error => {
        console.error(`‚ùå Erro ao gerar explica√ß√£o intermedi√°ria em background:`, error);
      });
      
      // Gerar perguntas para avan√ßado (em background)
      gerarExplicacao(materia, 'avancado').then(explicAvancado => {
        gerarPerguntas(materia, explicAvancado, 'avancado').then(perguntasAvancado => {
          niveis.avancado = perguntasAvancado;
          console.log(`‚úÖ Perguntas para n√≠vel avan√ßado armazenadas em background.`);
        }).catch(error => {
          console.error(`‚ùå Erro ao gerar perguntas avan√ßadas em background:`, error);
          gerarPerguntasPlaceholder(materia, 'avancado').then(placeholders => {
            niveis.avancado = placeholders;
          });
        });
      }).catch(error => {
        console.error(`‚ùå Erro ao gerar explica√ß√£o avan√ßada em background:`, error);
      });
    }

  } catch (error) { // Captura erros gerais do processo ensinarMateria
    console.error(`‚ùå Erro geral ao ensinar mat√©ria ${materia}:`, error);
    // Retorna uma mensagem de erro que ser√° enviada ao usu√°rio
    throw new Error(`Erro ao gerar conte√∫do de estudo para ${materia}. ${error.message}`); 
  }
}

// Melhorar a fun√ß√£o verificarResposta para usar uma abordagem mais flex√≠vel e tolerante
async function verificarResposta(pergunta, respostaUsuario) {
  if (!progressoUsuario) {
    console.error("‚ùå Objeto progressoUsuario n√£o inicializado");
    return "Desculpe, ocorreu um erro ao verificar sua resposta. Por favor, reinicie o estudo.";
  }

  const respostaCorreta = pergunta.respostaCorreta;
  progressoUsuario.totalPerguntas++;
  
  // Verifica se est√° vazio ou muito curto
  if (!respostaUsuario || respostaUsuario.trim().length < 2) {
    return "Resposta muito curta. Por favor, forne√ßa uma resposta mais completa.";
  }
  
  try {
    console.log("ü§ñ Verificando resposta com OpenRouter...")
    console.log("üìù Pergunta:", pergunta.pergunta);
    console.log("üìù Resposta do usu√°rio:", respostaUsuario);
    console.log("üìù Resposta correta:", respostaCorreta);
    
    // Cria um prompt para a API
    const prompt = `Voc√™ √© um assistente educacional preciso que avalia respostas.
    
Pergunta: "${pergunta.pergunta}"
Resposta correta: "${respostaCorreta}"
Resposta do estudante: "${respostaUsuario}"

A resposta do estudante est√° correta considerando o significado e conceito? Avalie se a resposta demonstra compreens√£o do conceito, n√£o apenas correspond√™ncia textual exata.

D√™ o resultado como "CORRETO" ou "INCORRETO", seguido de uma breve explica√ß√£o de um ou dois pontos sobre por que a resposta est√° correta ou incorreta.

Formato de sa√≠da:
RESULTADO: [CORRETO/INCORRETO]
EXPLICA√á√ÉO: [breve explica√ß√£o]`;

    // Chama a API para verificar a resposta
    const resultadoAPI = await chamarOpenRouter(prompt, false);
    console.log("ü§ñ Resposta da API:", resultadoAPI);
    
    // Extrai o resultado (CORRETO ou INCORRETO)
    const resultado = resultadoAPI.match(/RESULTADO:\s*(CORRETO|INCORRETO)/i);
    const explicacao = resultadoAPI.match(/EXPLICA√á√ÉO:\s*(.+?)(?:\n|$)/is);
    
    const estaCorreto = resultado && resultado[1].toUpperCase() === "CORRETO";
    const textoExplicacao = explicacao ? explicacao[1].trim() : "";
    
    // Atualiza o progresso se estiver correto
    if (estaCorreto) {
      progressoUsuario.respostasCorretas++;
      return `Correto! ‚úÖ ${textoExplicacao}`;
    } else {
      return `Incorreto. ‚ùå ${textoExplicacao}\nA resposta correta seria: ${respostaCorreta}`;
    }
  } catch (error) {
    console.error("‚ùå Erro ao verificar resposta com API:", error);
    
    // Fallback para o m√©todo baseado em similaridade
    console.log("‚ö†Ô∏è Usando m√©todo de similaridade como fallback");
    
    // Normalizando as respostas
    const userNormalizado = respostaUsuario.toLowerCase()
      .replace(/[.,;:!?'"()\-]/g, '') // Remove pontua√ß√£o
      .replace(/\s+/g, ' ')           // Normaliza espa√ßos
      .trim();
    
    const correctNormalizado = respostaCorreta.toLowerCase()
      .replace(/[.,;:!?'"()\-]/g, '') // Remove pontua√ß√£o
      .replace(/\s+/g, ' ')           // Normaliza espa√ßos
      .trim();
    
    // Verifica√ß√£o exata ap√≥s normaliza√ß√£o
    if (userNormalizado === correctNormalizado) {
      progressoUsuario.respostasCorretas++;
      return "Correto! ‚úÖ (verificado por similaridade)";
    }
    
    // Verifica√ß√£o por conten√ß√£o de palavras-chave
    const palavrasChave = correctNormalizado.split(' ').filter(p => p.length > 3);
    const palavrasEncontradas = palavrasChave.filter(palavra => userNormalizado.includes(palavra));
    
    // MAIS TOLERANTE: Reduzimos o requisito para 55% das palavras-chave
    if (palavrasChave.length === 0 || palavrasEncontradas.length >= Math.ceil(palavrasChave.length * 0.55)) {
      progressoUsuario.respostasCorretas++;
      return "Correto! ‚úÖ Sua resposta cont√©m os elementos essenciais. (verificado por similaridade)";
    }
    
    // Verifica√ß√£o por similaridade
    const similaridade = calcularSimilaridade(userNormalizado, correctNormalizado);
    console.log(`üìä Similaridade entre respostas: ${(similaridade * 100).toFixed(1)}%`);
    
    // Reduzimos o limite para 45%
    if (similaridade > 0.45) {
      progressoUsuario.respostasCorretas++;
      return "Correto! ‚úÖ Sua resposta √© similar √† esperada. (verificado por similaridade)";
    }
    
    return "Incorreto. ‚ùå A resposta correta seria: " + respostaCorreta;
  }
}

// Fun√ß√£o auxiliar para extrair palavras fundamentais
function extrairPalavrasFundamentais(texto) {
  // Divide o texto em palavras
  const palavras = texto.split(' ');
  
  // Identifica palavras longas (substantivos, verbos importantes)
  // e filtra palavras comuns pouco significativas
  const palavrasComuns = ['com', 'que', 'para', 'por', 'dos', 'das', 'uma', 'nas', 'aos', 'seu', 'sua'];
  
  return palavras
    .filter(palavra => palavra.length > 5) // Palavras mais longas s√£o geralmente mais importantes
    .filter(palavra => !palavrasComuns.includes(palavra)); // Remove palavras comuns
}

// Fun√ß√£o para calcular a similaridade entre duas strings
function calcularSimilaridade(str1, str2) {
  const [shorter, longer] = [str1, str2].sort((a, b) => a.length - b.length);
  const longerLength = longer.length;
  if (longerLength === 0) return 1.0;
  return (longerLength - calcularDistanciaLevenshtein(longer, shorter)) / parseFloat(longerLength);
}

// Fun√ß√£o para calcular a dist√¢ncia de Levenshtein
function calcularDistanciaLevenshtein(a, b) {
  const an = a ? a.length : 0;
  const bn = b ? b.length : 0;
  if (an === 0) return bn;
  if (bn === 0) return an;
  const matrix = Array.from({ length: an + 1 }, () => Array(bn + 1).fill(0));
  for (let i = 0; i <= an; i++) matrix[i][0] = i;
  for (let j = 0; j <= bn; j++) matrix[0][j] = j;
  for (let i = 1; i <= an; i++) {
    for (let j = 1; j <= bn; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      );
    }
  }
  return matrix[an][bn];
}

function verificarProgresso() {
  const { respostasCorretas, totalPerguntas, totalPerguntasDoNivel } = progressoUsuario;
  
  // Verifica se totalPerguntas √© zero para evitar NaN
  const percentualAcertos = totalPerguntas > 0 ? (respostasCorretas / totalPerguntas) * 100 : 0;
  
  console.log(`üìä Progresso: ${respostasCorretas}/${totalPerguntas} (${percentualAcertos.toFixed(1)}%)`);

  // Se ainda n√£o respondeu todas as perguntas do n√≠vel, continue no mesmo n√≠vel
  if (totalPerguntas < totalPerguntasDoNivel) {
    return `Progresso atual: ${respostasCorretas}/${totalPerguntas} (${percentualAcertos.toFixed(1)}%) - Responda todas as ${totalPerguntasDoNivel} perguntas para avan√ßar.`;
  }
  
  // S√≥ avan√ßa de n√≠vel ap√≥s responder todas as perguntas e atingir o percentual m√≠nimo
  if (percentualAcertos >= 70 || respostasCorretas >= Math.ceil(totalPerguntasDoNivel * 0.7)) {
    let novoNivel = progressoUsuario.nivelAtual;
    
    if (progressoUsuario.nivelAtual === 'iniciante') {
      novoNivel = 'intermediario';
    } else if (progressoUsuario.nivelAtual === 'intermediario') {
      novoNivel = 'avancado';
    } else {
      return "Parab√©ns! Voc√™ completou todos os n√≠veis.";
    }
    
    // Atualizar n√≠vel e resetar contadores
    progressoUsuario.nivelAtual = novoNivel;
    
    // Ajustar o total de perguntas do novo n√≠vel
    const perguntasNovoNivel = niveis[novoNivel];
    progressoUsuario.totalPerguntasDoNivel = perguntasNovoNivel ? perguntasNovoNivel.length : 5;
    
    progressoUsuario.respostasCorretas = 0;
    progressoUsuario.totalPerguntas = 0;
    
    return `Voc√™ atingiu ${percentualAcertos.toFixed(1)}% de acertos! Avan√ßou para o n√≠vel ${novoNivel}.`;
  }
  
  // Se n√£o atingiu o percentual m√≠nimo, precisa tentar novamente
  progressoUsuario.respostasCorretas = 0;
  progressoUsuario.totalPerguntas = 0;
  return `Voc√™ atingiu ${percentualAcertos.toFixed(1)}% de acertos. Precisa de pelo menos 70% para avan√ßar. Tente novamente!`;
}

async function gerarExplicacao(materia, nivel = 'iniciante') {
  console.log(`ü§ñ Gerando explica√ß√£o din√¢mica para: ${materia} (N√≠vel: ${nivel})`);
  
  let profundidade;
  switch(nivel) {
    case 'intermediario':
      profundidade = "Forne√ßa uma explica√ß√£o de n√≠vel intermedi√°rio, aprofundando nos conceitos. Inclua exemplos pr√°ticos e algumas aplica√ß√µes.";
      break;
    case 'avancado':
      profundidade = "Forne√ßa uma explica√ß√£o avan√ßada e detalhada, abordando aspectos complexos e nuances do tema. Inclua discuss√µes sobre teoria, aplica√ß√µes avan√ßadas e tend√™ncias atuais.";
      break;
    case 'iniciante':
    default:
      profundidade = "Forne√ßa uma explica√ß√£o b√°sica e introdut√≥ria, focando nos conceitos fundamentais e defini√ß√µes essenciais.";
  }
  
  const prompt = `Explique o t√≥pico "${materia}" para um estudante de n√≠vel ${nivel}. ${profundidade} 
  A explica√ß√£o deve ser abrangente o suficiente para que o estudante possa responder a perguntas sobre o tema.
  Estruture a explica√ß√£o em t√≥picos claros e inclua exemplos onde apropriado.`;
  
  try {
    // Tentar obter a explica√ß√£o da API
    const explicacaoTexto = await chamarOpenRouter(prompt, false);
    
    // Verifica√ß√£o de sanidade
    if (!explicacaoTexto || explicacaoTexto.length < 50) { 
      console.log("‚ö†Ô∏è Explica√ß√£o gerada muito curta ou inv√°lida, usando fallback.");
      return gerarExplicacaoFallback(materia, nivel);
    }
    
    return explicacaoTexto;
  } catch (error) {
    console.error(`‚ùå Falha ao gerar explica√ß√£o din√¢mica para ${materia} (N√≠vel: ${nivel}):`, error);
    // Usar explica√ß√£o de fallback em caso de erro na API
    console.log("üîÑ Usando explica√ß√£o de fallback devido a erro na API.");
    return gerarExplicacaoFallback(materia, nivel);
  }
}

async function gerarPerguntas(materia, explicacao, nivel = 'iniciante') {
  console.log(`ü§ñ Gerando perguntas din√¢micas para: ${materia} (N√≠vel: ${nivel})`);
  
  // Resumo da explica√ß√£o para incluir no prompt (limitado para n√£o exceder o contexto)
  const explicacaoResumida = explicacao.length > 500 ? explicacao.substring(0, 500) + "..." : explicacao;
  
  const prompt = `Com base na seguinte explica√ß√£o sobre "${materia}":
  
  ${explicacaoResumida}
  
  Gere 5 perguntas de m√∫ltipla escolha para o n√≠vel "${nivel}". As perguntas devem ser diretamente baseadas no conte√∫do da explica√ß√£o acima.
  
  Para cada pergunta, forne√ßa a pergunta em si ('pergunta') e a resposta correta ('respostaCorreta').
  
  Retorne APENAS um objeto JSON com a seguinte estrutura:
  {
    "perguntas": [
      { "pergunta": "...", "respostaCorreta": "..." },
      // ...mais perguntas
    ]
  }`;

  try {
    let respostaTexto = await chamarOpenRouter(prompt, true); // Espera JSON

    // Limpa poss√≠veis marcadores Markdown antes do parse
    console.log("üìù Limpando resposta da API antes do parse...");
    respostaTexto = respostaTexto.trim();
    if (respostaTexto.startsWith("```json")) {
        respostaTexto = respostaTexto.substring(7, respostaTexto.length - 3).trim();
    } else if (respostaTexto.startsWith("```")) {
        respostaTexto = respostaTexto.substring(3, respostaTexto.length - 3).trim();
    }
    console.log("üìù Resposta limpa:", respostaTexto);

    const perguntasObj = JSON.parse(respostaTexto);

    // Valida√ß√£o da estrutura recebida
    if (!perguntasObj || 
        !Array.isArray(perguntasObj.perguntas) || 
        perguntasObj.perguntas.length < 3 ||
        !perguntasObj.perguntas[0].pergunta || 
        !perguntasObj.perguntas[0].respostaCorreta) {
      console.error("‚ùå Estrutura JSON de perguntas inv√°lida recebida da API:", perguntasObj);
      throw new Error("A API retornou perguntas em formato inv√°lido.");
    }
    
    console.log("‚úÖ Perguntas JSON recebidas e validadas para n√≠vel:", nivel);
    return perguntasObj.perguntas;

  } catch (error) {
    console.error(`‚ùå Falha ao gerar/parsear perguntas din√¢micas para ${materia} (N√≠vel: ${nivel}):`, error);
    throw new Error(`N√£o foi poss√≠vel gerar perguntas para ${materia} via API.`);
  }
}

// Fun√ß√£o para gerar explica√ß√£o de fallback espec√≠ficas para cada mat√©ria
function gerarExplicacaoFallback(materia, nivel = 'iniciante') {
  console.log(`‚ö†Ô∏è Usando explica√ß√£o fallback para ${materia} (n√≠vel ${nivel})`);
  
  // Explica√ß√µes espec√≠ficas para mat√©rias conhecidas
  const explicacoesPadrao = {
    'cdb e cdi': {
      iniciante: `# CDB e CDI - Conceitos B√°sicos

O CDB (Certificado de Dep√≥sito Banc√°rio) √© um t√≠tulo de renda fixa emitido por bancos. Quando voc√™ investe em um CDB, est√° emprestando dinheiro ao banco em troca de uma remunera√ß√£o futura.

O CDI (Certificado de Dep√≥sito Interbanc√°rio) representa a taxa m√©dia das opera√ß√µes de empr√©stimos entre bancos. √â a principal refer√™ncia para investimentos de renda fixa no Brasil.

Caracter√≠sticas principais do CDB:
- Garantia do FGC (Fundo Garantidor de Cr√©ditos) de at√© R$ 250 mil por CPF e institui√ß√£o financeira
- Tributa√ß√£o regressiva de IR (de 22,5% a 15%, dependendo do prazo)
- Rentabilidade geralmente expressa como % do CDI

Os CDBs podem ser:
- Prefixados: taxa definida no momento da aplica√ß√£o
- P√≥s-fixados: atrelados a um indexador como CDI ou IPCA
- H√≠bridos: combinam caracter√≠sticas dos dois tipos anteriores

Para investidores iniciantes, CDBs s√£o considerados seguros e oferecem rendimento superior √† poupan√ßa.`,

      intermediario: `# CDB e CDI - An√°lise Intermedi√°ria

## Certificado de Dep√≥sito Banc√°rio (CDB)
O CDB √© um instrumento de capta√ß√£o de recursos utilizado pelos bancos comerciais. Ao comprar um CDB, o investidor se torna credor da institui√ß√£o financeira.

### Tipos de CDB:
1. **Prefixados**: Rentabilidade definida no momento da aplica√ß√£o, independente das varia√ß√µes futuras das taxas de juros.
2. **P√≥s-fixados**: Rentabilidade varia conforme um indexador (normalmente CDI).
3. **H√≠bridos**: Combinam caracter√≠sticas prefixadas e p√≥s-fixadas, como CDBs "IPCA + taxa prefixada".

### Tributa√ß√£o:
- IR regressivo de 22,5% a 15%, conforme prazo do investimento:
  - At√© 180 dias: 22,5%
  - De 181 a 360 dias: 20%
  - De 361 a 720 dias: 17,5%
  - Acima de 720 dias: 15%
- IOF regressivo para resgates antes de 30 dias

## Certificado de Dep√≥sito Interbanc√°rio (CDI)
O CDI √© um t√≠tulo de emiss√£o das institui√ß√µes financeiras para equilibrar liquidez entre bancos. Sua taxa serve como benchmark para o mercado de renda fixa.

A taxa CDI acompanha de perto a taxa Selic, normalmente ficando um pouco abaixo. As diferen√ßas ocorrem devido √† din√¢mica entre os bancos e √†s expectativas de mercado.

### Caracter√≠sticas da liquidez:
- Alguns CDBs permitem resgate antecipado (liquidez di√°ria)
- Outros s√≥ podem ser resgatados no vencimento
- No resgate antecipado, aplica-se marca√ß√£o a mercado, que pode resultar em rendimento menor que o esperado

Os CDBs s√£o uma ferramenta importante para diversifica√ß√£o em renda fixa e podem compor a parcela conservadora de uma carteira de investimentos.`,

      avancado: `# CDB e CDI - An√°lise Avan√ßada

## Precifica√ß√£o e Estrutura√ß√£o dos CDBs
A precifica√ß√£o de CDBs √© influenciada por diversos fatores macroecon√¥micos e espec√≠ficos da institui√ß√£o emissora:

### Fatores Estruturais:
1. **Basileia III**: O Acordo de Basileia III estabelece regras mais r√≠gidas de capital e liquidez, influenciando diretamente o apetite dos bancos pela capta√ß√£o via CDB.
2. **Rating da Institui√ß√£o**: Bancos com classifica√ß√£o de risco inferior frequentemente oferecem CDBs com taxas mais elevadas para compensar o risco percebido.
3. **Estrat√©gia de Funding**: O mix de capta√ß√£o dos bancos (dep√≥sitos √† vista, poupan√ßa, CDBs, LCAs, etc.) impacta a precifica√ß√£o de cada instrumento.

### Marca√ß√£o a Mercado (MtM):
A MtM √© fundamental para entender o valor de mercado de um CDB prefixado em caso de resgate antecipado. A rela√ß√£o entre taxas de juros e pre√ßo √© inversamente proporcional:

- Se as taxas de mercado sobem ap√≥s a compra do CDB:
  - O valor presente do t√≠tulo cai
  - Em caso de resgate antecipado, o investidor pode ter rendimento inferior ao esperado

- Se as taxas de mercado caem ap√≥s a compra do CDB:
  - O valor presente do t√≠tulo sobe
  - Em caso de resgate antecipado, o investidor pode ter ganho adicional

### Curva de Juros e Estrutura a Termo:
A curva de juros futuros do CDI √© essencial para a precifica√ß√£o de CDBs de longo prazo. A formata√ß√£o da curva (normal, invertida ou flat) sinaliza as expectativas do mercado:

- **Curva normal** (ascendente): Expectativa de alta das taxas de juros
- **Curva invertida** (descendente): Expectativa de queda das taxas de juros
- **Curva flat** (plana): Estabilidade esperada nas taxas

### Estrat√©gias Avan√ßadas:
- **Ladder (Escada) de CDBs**: Aloca√ß√£o em v√°rios CDBs com vencimentos escalonados para reduzir risco de reinvestimento e aumentar liquidez
- **Barbell**: Concentra√ß√£o em CDBs de curto e longo prazo, evitando prazos intermedi√°rios
- **Bullet**: Concentra√ß√£o em um prazo espec√≠fico alinhado com o horizonte de investimento

### Compara√ß√£o com Outros Instrumentos:
- **Opera√ß√µes Compromissadas**: Oferecem liquidez imediata com lastro em t√≠tulos p√∫blicos, mas geralmente com rentabilidade inferior aos CDBs
- **Deb√™ntures**: Podem oferecer taxas superiores, mas com risco de cr√©dito privado
- **LCAs/LCIs**: Isentas de IR, mas com restri√ß√µes de liquidez e, geralmente, taxas inferiores aos CDBs equivalentes

O entendimento das nuances t√©cnicas dos CDBs e CDI permite ao investidor sofisticado otimizar aloca√ß√µes, realizar opera√ß√µes estruturadas e aproveitar inefici√™ncias pontuais de mercado.`
    }
  };
  
  // Normalizar a mat√©ria para busca case-insensitive
  const materiaLower = materia.toLowerCase();
  
  // Se for uma mat√©ria conhecida, retorna a explica√ß√£o espec√≠fica
  for (const [chave, explicacoes] of Object.entries(explicacoesPadrao)) {
    if (materiaLower.includes(chave) || chave.includes(materiaLower)) {
      return explicacoes[nivel] || explicacoes['iniciante']; // Fallback para n√≠vel iniciante se o n√≠vel solicitado n√£o existir
    }
  }
  
  // Explica√ß√£o gen√©rica para mat√©rias desconhecidas
  switch(nivel) {
    case 'intermediario':
      return `# ${materia} - N√≠vel Intermedi√°rio

Esta √© uma explica√ß√£o de fallback para ${materia} em n√≠vel intermedi√°rio.

Infelizmente, n√£o foi poss√≠vel gerar uma explica√ß√£o personalizada para este tema. Recomendamos tentar novamente mais tarde ou escolher um tema mais espec√≠fico.

Enquanto isso, voc√™ pode consultar fontes confi√°veis sobre ${materia} para aprofundar seus conhecimentos.`;
      
    case 'avancado':
      return `# ${materia} - N√≠vel Avan√ßado

Esta √© uma explica√ß√£o de fallback para ${materia} em n√≠vel avan√ßado.

N√£o foi poss√≠vel gerar uma explica√ß√£o personalizada detalhada para este tema. Recomendamos consultar literatura especializada ou tentar novamente mais tarde.

Para estudos avan√ßados em ${materia}, √© recomend√°vel buscar artigos cient√≠ficos e publica√ß√µes acad√™micas recentes.`;
      
    case 'iniciante':
    default:
      return `# ${materia} - Conceitos B√°sicos

Esta √© uma explica√ß√£o b√°sica de fallback para ${materia}.

Infelizmente, n√£o foi poss√≠vel gerar uma explica√ß√£o personalizada para este tema no momento. Recomendamos tentar novamente mais tarde.

Para come√ßar seus estudos em ${materia}, recomendamos buscar defini√ß√µes b√°sicas e conceitos introdut√≥rios em livros did√°ticos ou sites educacionais confi√°veis.`;
  }
}

// Fun√ß√£o para gerar perguntas placeholder em caso de falha da API
async function gerarPerguntasPlaceholder(materia, nivel = 'iniciante') {
    console.warn(`‚ö†Ô∏è Usando perguntas placeholder para: ${materia} (N√≠vel: ${nivel})`);
    
    // Perguntas espec√≠ficas para CDB e CDI
    const perguntasEspecificas = {
      'cdb e cdi': {
        iniciante: [
          { 
            pergunta: "O que significa a sigla CDB?", 
            respostaCorreta: "Certificado de Dep√≥sito Banc√°rio" 
          },
          { 
            pergunta: "Qual √© a principal fun√ß√£o do CDB?", 
            respostaCorreta: "Captar recursos para os bancos, funcionando como um empr√©stimo do investidor para a institui√ß√£o financeira" 
          },
          { 
            pergunta: "O que o CDI representa no contexto de investimentos?", 
            respostaCorreta: "√â uma taxa de refer√™ncia para investimentos de renda fixa, baseada nas opera√ß√µes entre bancos" 
          },
          { 
            pergunta: "Se um CDB rende 110% do CDI e o CDI acumula 10% em um ano, quanto receber√° um investidor que aplicou R$ 1.000?", 
            respostaCorreta: "R$ 1.110" 
          },
          { 
            pergunta: "At√© que valor o CDB √© garantido pelo FGC (Fundo Garantidor de Cr√©ditos)?", 
            respostaCorreta: "At√© R$ 250 mil por CPF e institui√ß√£o financeira" 
          }
        ],
        
        intermediario: [
          { 
            pergunta: "Quais s√£o os tr√™s tipos principais de CDBs quanto √† forma de remunera√ß√£o?", 
            respostaCorreta: "Prefixados, p√≥s-fixados e h√≠bridos" 
          },
          { 
            pergunta: "Como funciona a tributa√ß√£o de Imposto de Renda sobre o CDB para um investimento de 2 anos?", 
            respostaCorreta: "Al√≠quota de 15% sobre o rendimento, conforme a tabela regressiva" 
          },
          { 
            pergunta: "Qual √© a rela√ß√£o entre a Taxa Selic e o CDI?", 
            respostaCorreta: "O CDI normalmente acompanha de perto a Taxa Selic, sendo um pouco menor" 
          },
          { 
            pergunta: "O que acontece com o rendimento de um CDB prefixado se a taxa Selic subir durante o per√≠odo de investimento?", 
            respostaCorreta: "O rendimento nominal permanece o mesmo, mas o rendimento real pode ficar menos atrativo comparado a novos investimentos" 
          },
          { 
            pergunta: "Al√©m do Imposto de Renda, que outro imposto pode incidir sobre resgates de CDB?", 
            respostaCorreta: "IOF (Imposto sobre Opera√ß√µes Financeiras) para resgates antes de 30 dias" 
          }
        ],
        
        avancado: [
          { 
            pergunta: "Como a curva de juros do CDI influencia a precifica√ß√£o de CDBs de longo prazo?", 
            respostaCorreta: "A curva de juros do CDI representa as taxas futuras esperadas, permitindo que os bancos precifiquem CDBs de longo prazo de acordo com as expectativas do mercado para as taxas de juros" 
          },
          { 
            pergunta: "O que √© a estrat√©gia 'ladder' (escada) de CDBs e quais seus benef√≠cios?", 
            respostaCorreta: "√â a distribui√ß√£o de recursos em CDBs com diferentes vencimentos, permitindo reinvestimentos peri√≥dicos a novas taxas e melhor gerenciamento de liquidez" 
          },
          { 
            pergunta: "Como as regras de Basileia III afetam a oferta e precifica√ß√£o de CDBs pelos bancos?", 
            respostaCorreta: "As regras de Basileia III exigem √≠ndices de capital mais elevados, o que pode levar alguns bancos a oferecer CDBs com taxas mais atrativas para captar recursos e melhorar seus indicadores de liquidez" 
          },
          { 
            pergunta: "Explique como funciona a marca√ß√£o a mercado (MtM) em CDBs prefixados e seu impacto para o investidor em caso de resgate antecipado.", 
            respostaCorreta: "Na marca√ß√£o a mercado, CDBs prefixados s√£o reavaliados diariamente conforme as taxas de mercado. Se as taxas subirem ap√≥s a compra, o valor de mercado cai, gerando preju√≠zo em resgates antecipados. Se as taxas ca√≠rem, o valor de mercado sobe, gerando ganho adicional" 
          },
          { 
            pergunta: "Qual a diferen√ßa entre uma opera√ß√£o compromissada e um CDB do ponto de vista da capta√ß√£o banc√°ria?", 
            respostaCorreta: "Nas opera√ß√µes compromissadas, o banco vende t√≠tulos com compromisso de recompra, oferecendo lastro; no CDB, o banco emite um t√≠tulo de d√≠vida sem lastro espec√≠fico. As compromissadas t√™m prazos geralmente mais curtos e tratamento cont√°bil diferente nas institui√ß√µes financeiras" 
          }
        ]
      }
    };
    
    // Normalizar a mat√©ria para busca case-insensitive
    const materiaLower = materia.toLowerCase();
    
    // Verificar se temos perguntas espec√≠ficas para esta mat√©ria
    for (const [chave, perguntas] of Object.entries(perguntasEspecificas)) {
      if (materiaLower.includes(chave) || chave.includes(materiaLower)) {
        return perguntas[nivel] || perguntas['iniciante']; // Fallback para n√≠vel iniciante se o n√≠vel solicitado n√£o existir
      }
    }
    
    // Se n√£o encontrou perguntas espec√≠ficas, usa perguntas gen√©ricas
    let perguntas;
    switch(nivel) {
      case 'intermediario':
        perguntas = [
          { pergunta: `Explique os princ√≠pios fundamentais de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 1" },
          { pergunta: `Como ${materia} se relaciona com outras √°reas? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 2" },
          { pergunta: `Quais s√£o as principais teorias em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 3" },
          { pergunta: `Desafios encontrados no estudo de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 4" },
          { pergunta: `M√©todos utilizados para pesquisa em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 5" }
        ];
        break;
      case 'avancado':
        perguntas = [
          { pergunta: `Problemas complexos em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 1" },
          { pergunta: `Estado atual da pesquisa em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 2" },
          { pergunta: `Tend√™ncias futuras em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 3" },
          { pergunta: `Casos avan√ßados de aplica√ß√£o de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 4" },
          { pergunta: `Integra√ß√£o de ${materia} com tecnologias emergentes? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 5" }
        ];
        break;
      case 'iniciante':
      default:
        perguntas = [
          { pergunta: `O que √© ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 1" },
          { pergunta: `Quando surgiu ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 2" },
          { pergunta: `Quais s√£o os principais conceitos de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 3" },
          { pergunta: `Como ${materia} √© aplicado no dia a dia? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 4" },
          { pergunta: `Quais s√£o os benef√≠cios de estudar ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 5" }
        ];
    }
    
    return perguntas;
}

async function enviarProximaPergunta(jid, isGroup) {
  const estado = estadoConversa[jid];
  if (!estado) {
    console.error('Estado da conversa n√£o encontrado para:', jid);
    return;
  }

  const perguntas = niveis[estado.nivelAtual];
  if (!perguntas || perguntas.length === 0) {
    console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
    await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGroup);
    delete estadoConversa[jid]; // Limpa o estado para evitar problemas
    return;
  }

  if (estado.indicePergunta >= perguntas.length) {
    console.error('√çndice de pergunta fora dos limites:', estado.indicePergunta, 'de', perguntas.length);
    await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar a pr√≥xima pergunta. Por favor, inicie um novo estudo.' }, isGroup);
    delete estadoConversa[jid]; // Limpa o estado para evitar problemas
    return;
  }

  const perguntaAtual = perguntas[estado.indicePergunta];
  if (!perguntaAtual) {
    console.error('Pergunta atual n√£o encontrada para:', jid);
    return;
  }

  await enviarMensagemComDelay(jid, { text: `‚ùì Pergunta: ${perguntaAtual.pergunta}` }, isGroup);
}

// Modificar para evitar m√∫ltiplas transi√ß√µes de n√≠vel ou mensagens duplicadas
async function processarResposta(jid, texto, isGroup) {
  // Evita processamento concorrente de respostas
  if (processandoRespostaFlag) {
    console.log("‚ö†Ô∏è J√° existe um processamento de resposta em andamento. Ignorando.");
    return;
  }
  
  processandoRespostaFlag = true;
  
  try {
    const estado = estadoConversa[jid];
    if (!estado) {
      console.error('Estado da conversa n√£o encontrado para:', jid);
      processandoRespostaFlag = false;
      return;
    }
    
    const perguntas = niveis[estado.nivelAtual];
    if (!perguntas || perguntas.length === 0) {
      console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
      await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGroup);
      delete estadoConversa[jid];
      processandoRespostaFlag = false;
      return;
    }

    if (estado.indicePergunta >= perguntas.length) {
      console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} j√° foram respondidas`);
      const progresso = verificarProgresso();
      await enviarMensagemComDelay(jid, { text: progresso }, isGroup);
      
      // Verifica se avan√ßou de n√≠vel
      const nivelAnterior = estado.nivelAtual;
      const nivelAtual = progressoUsuario.nivelAtual;
      
      if (nivelAtual !== nivelAnterior) {
        // Evita m√∫ltiplas tentativas de enviar explica√ß√µes
        if (envioExplicacaoEmAndamento[jid]) {
          console.log(`‚ö†Ô∏è J√° existe um envio de explica√ß√£o em andamento para ${jid}. Ignorando.`);
          processandoRespostaFlag = false;
          return;
        }
        
        envioExplicacaoEmAndamento[jid] = true;
        
        try {
          await enviarMensagemComDelay(jid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${nivelAtual}. Preparando nova explica√ß√£o...` }, isGroup);
          
          const materia = estado.materia;
          let explicacao;
          
          try {
            // Tenta obter explica√ß√£o via API apenas uma vez
            explicacao = await gerarExplicacao(materia, nivelAtual);
          } catch (error) {
            console.error(`‚ùå Erro ao gerar explica√ß√£o para novo n√≠vel:`, error);
            explicacao = gerarExplicacaoFallback(materia, nivelAtual);
          }
          
          await enviarMensagemComDelay(jid, { text: `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}` }, isGroup);
          
          // Atualiza o estado para o novo n√≠vel
          estado.nivelAtual = nivelAtual;
          estado.indicePergunta = 0;
          
          // Prepara perguntas para o novo n√≠vel, se necess√°rio
          if (!niveis[nivelAtual] || niveis[nivelAtual].length === 0) {
            try {
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            } catch (error) {
              console.error(`‚ùå Erro ao gerar perguntas para novo n√≠vel:`, error);
              // Use perguntas placeholders como fallback
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            }
          }
          
          // Envia a primeira pergunta do novo n√≠vel ap√≥s delay
          await delay(2000);
          await enviarProximaPergunta(jid, isGroup);
        } catch (error) {
          console.error(`‚ùå Erro ao processar avan√ßo de n√≠vel:`, error);
          await enviarMensagemComDelay(jid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${nivelAtual}. Por favor, reinicie o estudo.` }, isGroup);
          delete estadoConversa[jid];
        } finally {
          // Remove o flag de envio em andamento
          delete envioExplicacaoEmAndamento[jid];
        }
      } else {
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        estado.indicePergunta = 0;
        await enviarMensagemComDelay(jid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGroup);
        await delay(1000);
        await enviarProximaPergunta(jid, isGroup);
      }
      
      processandoRespostaFlag = false;
      return;
    }

    const perguntaAtual = perguntas[estado.indicePergunta];
    if (!perguntaAtual) {
      console.error('Pergunta atual n√£o encontrada para:', jid);
      processandoRespostaFlag = false;
      return;
    }

    console.log('üß† Verificando resposta para:', perguntaAtual.pergunta);
    console.log('üß† Resposta do usu√°rio:', texto);
    console.log('üß† Resposta correta:', perguntaAtual.respostaCorreta);
    
    // Enviar mensagem de feedback indicando que a resposta est√° sendo processada
    await enviarMensagemComDelay(jid, { text: "‚è≥ Analisando sua resposta..." }, isGroup);
    
    // Agora verificarResposta √© uma fun√ß√£o ass√≠ncrona
    const resposta = await verificarResposta(perguntaAtual, texto);
    await enviarMensagemComDelay(jid, { text: resposta }, isGroup);

    // Avan√ßa para a pr√≥xima pergunta independentemente se acertou ou n√£o
    estado.indicePergunta++;
    
    // Se ainda tem mais perguntas no n√≠vel atual, envia a pr√≥xima
    if (estado.indicePergunta < perguntas.length) {
      await enviarProximaPergunta(jid, isGroup);
    } else {
      // Se j√° respondeu todas, finaliza o n√≠vel e verifica se pode avan√ßar
      console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} foram respondidas`);
      const progresso = verificarProgresso();
      await enviarMensagemComDelay(jid, { text: progresso }, isGroup);
      
      // Verifica se avan√ßou de n√≠vel
      const nivelAnterior = estado.nivelAtual;
      const nivelAtual = progressoUsuario.nivelAtual;
      
      if (nivelAtual !== nivelAnterior) {
        // Evita m√∫ltiplas tentativas de enviar explica√ß√µes
        if (envioExplicacaoEmAndamento[jid]) {
          console.log(`‚ö†Ô∏è J√° existe um envio de explica√ß√£o em andamento para ${jid}. Ignorando.`);
          processandoRespostaFlag = false;
          return;
        }
        
        envioExplicacaoEmAndamento[jid] = true;
        
        try {
          await enviarMensagemComDelay(jid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${nivelAtual}. Preparando nova explica√ß√£o...` }, isGroup);
          
          const materia = estado.materia;
          let explicacao;
          
          try {
            // Tenta obter explica√ß√£o via API apenas uma vez
            explicacao = await gerarExplicacao(materia, nivelAtual);
          } catch (error) {
            console.error(`‚ùå Erro ao gerar explica√ß√£o para novo n√≠vel:`, error);
            explicacao = gerarExplicacaoFallback(materia, nivelAtual);
          }
          
          await enviarMensagemComDelay(jid, { text: `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}` }, isGroup);
          
          // Atualiza o estado para o novo n√≠vel
          estado.nivelAtual = nivelAtual;
          estado.indicePergunta = 0;
          
          // Prepara perguntas para o novo n√≠vel, se necess√°rio
          if (!niveis[nivelAtual] || niveis[nivelAtual].length === 0) {
            try {
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            } catch (error) {
              console.error(`‚ùå Erro ao gerar perguntas para novo n√≠vel:`, error);
              // Use perguntas placeholders como fallback
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            }
          }
          
          // Envia a primeira pergunta do novo n√≠vel ap√≥s delay
          await delay(2000);
          await enviarProximaPergunta(jid, isGroup);
        } catch (error) {
          console.error(`‚ùå Erro ao processar avan√ßo de n√≠vel:`, error);
          await enviarMensagemComDelay(jid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${nivelAtual}. Por favor, reinicie o estudo.` }, isGroup);
          delete estadoConversa[jid];
        } finally {
          // Remove o flag de envio em andamento
          delete envioExplicacaoEmAndamento[jid];
        }
      } else {
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        estado.indicePergunta = 0;
        await enviarMensagemComDelay(jid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGroup);
        await delay(1000);
        await enviarProximaPergunta(jid, isGroup);
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao processar resposta:', error);
  } finally {
    processandoRespostaFlag = false;
  }
}

// Inicia o servidor
iniciarConexaoWhatsApp().then(() => {
  app.listen(3000, () => console.log("Servidor rodando na porta 3000!"));
});