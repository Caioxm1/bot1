const crypto = require('crypto')
globalThis.crypto = crypto.webcrypto;
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason } = require('@whiskeysockets/baileys');
const axios = require('axios');
const express = require('express');
const { ChartJSNodeCanvas } = require('chartjs-node-canvas');
const WebSocket = require('ws');
const app = express();
const NIVEL_APRENDIZADO = {
  BASICO: { meta: 70, revisao: 24 }, // Horas entre revis√µes
  INTERMEDIARIO: { meta: 80, revisao: 48 },
  AVANCADO: { meta: 90, revisao: 72 }
};

app.use(express.json());

const OPENROUTER_API_KEY = "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";
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzfdPVe8l1OnXHw6i6kkk3NV9gTt2-oC0sE2WLDuN6InBU1K5kopMyT07kElsCulrNY/exec';
const GRUPOS_PERMITIDOS = [
  '120363420675161205@g.us' // Grupo original
];
const USUARIOS_AUTORIZADOS = [
  '5521975874116@s.whatsapp.net', // N1
  '5521976919619@s.whatsapp.net' // N2
];
const chartJSNodeCanvas = new ChartJSNodeCanvas({
  width: 800,
  height: 600,
  backgroundColour: 'white'
});

const wss = new WebSocket.Server({ port: 8080 });

let ultimoComandoProcessado = null;

const niveis = {
  iniciante: [],
  intermediario: [],
  avancado: []
};

let progressoUsuario = {
  nivelAtual: 'iniciante',
  respostasCorretas: 0,
  totalPerguntas: 0,
  totalPerguntasDoNivel: 0
};

let estadoConversa = {};

// Adicionar um controle para evitar processamentos duplicados
let processandoRespostaFlag = false;
let envioExplicacaoEmAndamento = {};

// Fun√ß√£o para log detalhado
function logMensagem(msg, tipo = 'recebida') {
  const dataHora = new Date().toISOString();
  const remetente = msg?.pushName || 'Desconhecido';
  const texto = msg.message?.conversation || '(m√≠dia ou mensagem sem texto)';
  const chatId = msg.key.remoteJid;
  
  console.log(`[${dataHora}] Mensagem ${tipo}:`);
  console.log(`De: ${remetente} (${chatId})`);
  console.log(`Texto: ${texto}`);
  console.log('---');
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function enviarMensagemComDelay(jid, conteudo, isGroup = false) {
  if (!conteudo?.text) {
    console.error("‚ö†Ô∏è Tentativa de enviar mensagem sem texto!");
    conteudo = { text: "‚ùå Ocorreu um erro inesperado" }; // Fallback
  }
  await delay(1000);
  if (isGroup) {
    await sock.sendMessage(jid, conteudo, { quoted: null });
  } else {
    await sock.sendMessage(jid, conteudo);
  }
}

let ultimoComandoUsuario = { jid: null, timestamp: 0 }; // Renomeada para mais clareza

async function processarComando(jid, texto) {
  // Ignora mensagens do pr√≥prio bot
  if (texto.includes("‚è≥ Aguarde") || texto.includes("‚ùå Erro")) {
    return null;
  }

  const agora = Date.now();
  if (ultimoComandoUsuario.jid === jid && (agora - ultimoComandoUsuario.timestamp) < 2000) {
    return "‚è≥ Aguarde 2 segundos antes de outro comando.";
  }
  
  ultimoComandoUsuario = { jid, timestamp: agora };
  return null;
}

// Lista de comandos para o comando "ajuda"
const LISTA_DE_COMANDOS = `
üìö *Lista de Comandos de Estudo* üìö

üìÖ *Agendamento*
- estudar [mat√©ria]: Inicia/retoma estudos de uma mat√©ria
- agendar [mat√©ria] [data] [hora]: Agenda um bloco de estudo
- cronograma: Mostra sua agenda de estudos
- concluir [id]: Marca sess√£o como conclu√≠da

üìù *Anota√ß√µes*
- anotar [mat√©ria] [texto]: Adiciona uma anota√ß√£o
- anota√ß√µes [mat√©ria]: Lista anota√ß√µes de uma mat√©ria
- buscar [termo]: Busca em todas anota√ß√µes

üîÑ *Revis√£o*
- flashcard [mat√©ria]: Mostra um flashcard para revis√£o
- responder [resposta]: Responde o flashcard atual
- estat√≠sticas: Mostra desempenho nos flashcards

üìä *Acompanhamento*
- metas: Mostra suas metas de estudo
- definir meta [mat√©ria] [horas]: Define meta semanal
- progresso: Mostra progresso nas mat√©rias

üìã *Avalia√ß√µes*
- prova [mat√©ria] [data]: Agenda uma prova
- simulado [tipo] [data]: Agenda simulado
- resultados: Mostra desempenho em avalia√ß√µes

üîß *Ajuda*
- ajuda: Mostra esta lista de comandos
`;

// Adicionando logs mais detalhados para erros
function logErroDetalhado(erro) {
  console.error("‚ùå Erro Detalhado:", erro.message);
  if (erro.response) {
    console.error("Status:", erro.response.status);
    console.error("Dados da resposta:", erro.response.data);
  }
  console.error("Stack:", erro.stack);
}

// Adicionar logs detalhados para erros de autentica√ß√£o
async function chamarOpenRouter(prompt, isJsonOutput = false) {
  console.log(`ü§ñ Chamando OpenRouter. JSON esperado: ${isJsonOutput}`);
  let tentativas = 0;
  const maxTentativas = 3;
  
  // Tempo de espera entre tentativas (aumenta exponencialmente)
  const temposDeEspera = [2000, 4000, 8000];

  while (tentativas < maxTentativas) {
    try {
      console.time("Tempo de resposta OpenRouter");
      console.log(`üì° Enviando requisi√ß√£o para OpenRouter (tentativa ${tentativas+1}/${maxTentativas})...`);
      
      // Verificar se a API key est√° definida corretamente
      if (!OPENROUTER_API_KEY || OPENROUTER_API_KEY.trim() === '') {
        console.error("üîë API key da OpenRouter n√£o configurada ou inv√°lida.");
        throw new Error("API key da OpenRouter n√£o configurada.");
      }
      
      const requestBody = {
        model: 'deepseek/deepseek-chat-v3-0324:free',
        messages: [{ role: 'user', content: prompt }],
      };
      if (isJsonOutput) {
        requestBody.response_format = { type: "json_object" };
      }

      // Configurar cabe√ßalhos de autentica√ß√£o corretamente
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
        'HTTP-Referer': 'http://localhost',
        'X-Title': 'Bot de Estudos'
      };

      // Usar os cabe√ßalhos configurados na requisi√ß√£o
      const resposta = await axios.post(
        'https://openrouter.ai/api/v1/chat/completions',
        requestBody,
        {
          headers: headers,
          timeout: 20000 // Aumentado para 20 segundos
        }
      );
      console.timeEnd("Tempo de resposta OpenRouter");

      if (!resposta.data?.choices?.[0]?.message?.content) {
        throw new Error("Resposta da API em formato inv√°lido ou vazia.");
      }

      console.log("üí¨ Resposta bruta da OpenRouter:", resposta.data.choices[0].message.content);
      
      // Se estamos esperando JSON, tenta validar que √© JSON v√°lido
      if (isJsonOutput) {
        try {
          const jsonResponse = JSON.parse(resposta.data.choices[0].message.content);
          return jsonResponse;
        } catch (e) {
          console.warn("‚ö†Ô∏è Resposta deveria ser JSON, mas n√£o p√¥de ser analisada:", e);
          // Retorna um objeto estruturado para indicar erro
          return { 
            status: 'error', 
            message: 'Falha ao processar resposta JSON',
            fallback: resposta.data.choices[0].message.content
          };
        }
      }
      
      return resposta.data.choices[0].message.content;

    } catch (error) {
      console.timeEnd("Tempo de resposta OpenRouter");
      tentativas++;
      
      // Log detalhado espec√≠fico para o erro
      console.error(`‚ùå Erro na chamada √† OpenRouter (tentativa ${tentativas}/${maxTentativas}):`);
      
      // Tratamento espec√≠fico para erros de autentica√ß√£o
      if (error.response?.status === 401) {
        console.error("üîë Erro de autentica√ß√£o (401): Credenciais inv√°lidas ou ausentes.");
        console.error("Detalhes:", error.response?.data || "Sem detalhes dispon√≠veis");
        // N√£o tentamos novamente em caso de erro de autentica√ß√£o
        throw new Error("Falha na autentica√ß√£o com a API OpenRouter. Verifique sua API key.");
      }
      
      // Tratamento para limites de requisi√ß√£o
      if (error.response?.status === 429) {
        console.error("üö´ Limite de requisi√ß√µes excedido na OpenRouter (429).");
        console.error("Detalhes:", error.response?.data || "Sem detalhes dispon√≠veis");
        console.log(`‚è≥ Aguardando ${temposDeEspera[tentativas-1]/1000} segundos antes de tentar novamente...`);
        await delay(temposDeEspera[tentativas-1]);
        continue; // Pula para a pr√≥xima tentativa sem lan√ßar exce√ß√£o
      }
      
      // Log para outros erros com resposta HTTP
      if (error.response) {
        console.error(`Status: ${error.response.status}`);
        console.error("Dados do erro:", error.response.data);
      }
      
      // Log para erros de rede ou timeout
      if (error.code === 'ECONNABORTED') {
        console.error("‚è±Ô∏è Timeout na requisi√ß√£o para OpenRouter.");
      } else if (!error.response) {
        console.error("üåê Erro de conex√£o:", error.message);
      }
      
      // Verificar se atingiu o m√°ximo de tentativas
      if (tentativas >= maxTentativas) {
         console.error(`üö´ Falha ao chamar OpenRouter ap√≥s ${maxTentativas} tentativas.`);
         throw new Error("Falha ao gerar conte√∫do ap√≥s m√∫ltiplas tentativas.");
      }

      console.log(`‚è≥ Tentando novamente em ${temposDeEspera[tentativas-1]/1000} segundos (Tentativa ${tentativas})...`);
      await delay(temposDeEspera[tentativas-1]);
    }
  }
}

async function criarMateria(nome) {
  console.log("üìö Criando nova mat√©ria:", nome);
  try {
    const nomeLimpo = nome.replace(/[^\w\s]/g, '').trim();
    const response = await chamarOpenRouter(`Crie um plano de ensino em JSON para "${nomeLimpo}" com 3 n√≠veis. Inclua t√≥picos e recursos.`, true);

    // Verifica√ß√£o rigorosa da resposta
    if (!response || response.status === 'error') {
      throw new Error(response?.message || "Resposta inv√°lida da API");
    }

    return response.message || "‚úÖ Mat√©ria criada com sucesso!"; // Fallback
  } catch (error) {
    console.error("‚ùå Erro ao criar mat√©ria:", error);
    return error.message || "‚ùå Erro desconhecido ao criar mat√©ria"; // Garante string
  }
}

async function agendarSessao(materia, data, hora, duracao = "", topico = "") {
  return await chamarOpenRouter(`Agende um bloco de estudo para "${materia}" no dia "${data}" √†s "${hora}". Se necess√°rio, especifique um t√≥pico ou dura√ß√£o adicional.`, true);
}

async function adicionarAnotacao(materia, topico, texto, tags = "") {
  return await chamarOpenRouter(`Adicione uma anota√ß√£o sobre "${materia}" no t√≥pico "${topico}". Anote o texto: "${texto}". Se necess√°rio, adicione tags: "${tags}".`, true);
}

async function criarFlashcard(materia, pergunta, resposta) {
  return await chamarOpenRouter(`Crie um flashcard para "${materia}" com a pergunta: "${pergunta}" e a resposta: "${resposta}".`, true);
}

async function definirMeta(materia, horas, data_limite) {
  return await chamarOpenRouter(`Defina uma meta de estudo para "${materia}" de ${horas} horas at√© "${data_limite}".`, true);
}

async function registrarAvaliacao(materia, tipo, data, resultado, topicos) {
  return await chamarOpenRouter(`Registre o resultado da avalia√ß√£o "${tipo}" para "${materia}" no dia "${data}". O resultado foi "${resultado}". Se necess√°rio, adicione coment√°rios sobre os t√≥picos: "${topicos}".`, true);
}

async function atualizarProgresso(materia_id, progresso) {
  return await chamarOpenRouter(`Atualize o progresso de "${materia_id}" para ${progresso}%.`, true);
}

async function alterarStatus(materia_id, status) {
  return await chamarOpenRouter(`Altere o status de "${materia_id}" para "${status}".`, true);
}

async function obterInfoMateria(materia_id) {
  return await chamarOpenRouter(`Forne√ßa informa√ß√µes sobre "${materia_id}".`, true);
}

// Fun√ß√£o de fallback para interpreta√ß√£o manual
function interpretarMensagemManual(texto) {
  console.log("\nüîÑ Usando interpreta√ß√£o manual para:", texto);
  
  const textoLower = texto.toLowerCase();
  
  // Padr√µes para detec√ß√£o de comandos
  if (textoLower.includes("estudar") || textoLower.includes("quero estudar") || textoLower.includes("vou estudar") || textoLower.includes("iniciar")) {
    // Extrai a mat√©ria ap√≥s a palavra "estudar" ou varia√ß√µes
    const materia = texto.split(/estudar|quero estudar|vou estudar|iniciar/i)[1]?.trim();
    if (materia) {
      console.log("üìö Mat√©ria extra√≠da:", materia);
      // Inicia o processo de cria√ß√£o de um plano de ensino
      return {
        comando: "estudar",
        parametros: { materia }
      };
    }
  }
  
  console.log("‚ö†Ô∏è Nenhum comando reconhecido");
  return null;
}

// Adicionar esta fun√ß√£o para detectar mensagens de sistema
function isMensagemSistema(texto) {
  // Padr√µes que identificam mensagens do sistema
  const padroesDoSistema = [
    /^progresso atual:/i,
    /^voc√™ atingiu [0-9.]+% de acertos/i,
    /^vamos recome√ßar as perguntas/i,
    /^parab√©ns!/i,
    /^‚ö†Ô∏è n√£o entendi qual comando/i,
    /^correto!/i,
    /^incorreto\./i
  ];
  
  return padroesDoSistema.some(padrao => padrao.test(texto));
}

// Modifique a verifica√ß√£o na fun√ß√£o pareceSerComandoEstudo para excluir mensagens de sistema
function pareceSerComandoEstudo(texto) {
  // Se for uma mensagem do sistema, retornar false imediatamente
  if (isMensagemSistema(texto)) {
    console.log("[pareceSerComandoEstudo] Mensagem do sistema detectada, ignorando como comando.");
    return false;
  }

  const palavrasChave = [
    "estudar", "aprender", "mat√©ria", "agendar", "cronograma",
    "anotar", "anota√ß√µes", "flashcard", "responder", "prova",
    "simulado", "meta", "metas", "progresso", "revisar",
    "concluir", "buscar", "estat√≠sticas", "resultados",
    "iniciar",
    "ensinar"
  ];
  
  const textoLower = texto.toLowerCase();
  
  // Verifica se cont√©m alguma palavra-chave
  const temPalavraChave = palavrasChave.some(palavra => 
    textoLower.includes(palavra.toLowerCase())
  );
  
  // Verifica se come√ßa com "estudar" ou varia√ß√µes (incluindo "ensinar" agora implicitamente via palavrasChave)
  const comecaComComando = /^(estudar|quero estudar|vou estudar|iniciar|ensinar)/i.test(textoLower);

  // Logs internos para depura√ß√£o
  console.log(`[pareceSerComandoEstudo] Texto: "${textoLower}"`);
  console.log(`[pareceSerComandoEstudo] Tem Palavra Chave? ${temPalavraChave}`);
  console.log(`[pareceSerComandoEstudo] Come√ßa com Comando? ${comecaComComando}`);
  
  const resultado = temPalavraChave || comecaComComando;
  console.log(`[pareceSerComandoEstudo] Resultado: ${resultado}`);
  return resultado;
}

// Fun√ß√£o principal do bot
let sock = null;

async function iniciarConexaoWhatsApp() {
  console.log('Iniciando conex√£o WhatsApp...');
  const { state, saveCreds } = await useMultiFileAuthState('auth_info');
  console.log('Estado da autentica√ß√£o:', state ? 'OK' : 'FALHA');
  
  sock = makeWASocket({
    auth: state,
    printQRInTerminal: true,
    browser: ['Bot de Estudos', 'Chrome', '115.0.0.0'],
    syncFullHistory: false
  });

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', (update) => {
    const { connection, lastDisconnect } = update;
    
    if (connection === 'close') {
      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
      console.log('Conex√£o fechada devido a ', lastDisconnect.error, ', reconectando:', shouldReconnect);
      if (shouldReconnect) {
        setTimeout(() => {
          console.log('Tentando reconectar...');
          iniciarConexaoWhatsApp();
        }, 3000);
      }
    } else if (connection === 'open') {
      console.log('‚úÖ Conex√£o estabelecida com sucesso!');
    }
  });

  sock.ev.on('messages.upsert', async ({ messages }) => {
      const msg = messages[0];
      if (!msg?.message || !msg.key?.remoteJid) return;

    // Extrair o texto da mensagem para verifica√ß√£o
    const texto = msg.message.conversation?.trim() || msg.message.extendedTextMessage?.text?.trim() || "";

    // IMPORTANTE: L√≥gica revisada para permitir mensagens enviadas pelo mesmo n√∫mero
    // 1. Verifica se a mensagem cont√©m padr√µes t√≠picos de mensagens do bot
    const isBotResponse = 
      (texto.startsWith('‚ùì') || 
       texto.startsWith('üìñ') ||
       texto.startsWith('Incorreto') ||
       texto.startsWith('Correto!') ||
       texto.startsWith('Progresso atual:') ||
       texto.startsWith('Voc√™ atingiu'));

    // 2. Se for do pr√≥prio n√∫mero mas n√£o parecer uma mensagem autom√°tica do bot,
    //    provavelmente √© uma mensagem manual do usu√°rio que devemos processar
    if (msg.key.fromMe && !isBotResponse && !isMensagemSistema(texto)) {
      // Esta √© possivelmente uma mensagem manual do usu√°rio usando o mesmo n√∫mero
      console.log('üì± Mensagem enviada manualmente do mesmo n√∫mero do bot. Processando normalmente.');
    } 
    // 3. Se for uma mensagem autom√°tica do bot ou mensagem de sistema, ignoramos
    else if (msg.key.fromMe || isMensagemSistema(texto)) {
      console.log('‚ö†Ô∏è Mensagem autom√°tica do bot ou mensagem de sistema. Ignorando para evitar loops.');
      return;
    }
    
    // Permite que comandos manuais do usu√°rio sejam processados
    const isUserCommand = pareceSerComandoEstudo(texto);

    // Verificar se o usu√°rio tem um estado de conversa ativo
    const temEstadoAtivo = estadoConversa[msg.key.remoteJid] !== undefined;

      console.log('\n=== NOVA MENSAGEM RECEBIDA ===');
      console.log('üì± Remetente:', msg.pushName || 'Desconhecido');
      console.log('üîë Chat ID:', msg.key.remoteJid);
    console.log('üîë Participant:', msg.key.participant);
    console.log('üîë fromMe:', msg.key.fromMe);
    console.log('üí¨ Texto:', texto);
    console.log('üîë Estado de conversa ativo:', temEstadoAtivo);
      
      // Ignora mensagens de status
      if (msg.key.remoteJid === 'status@broadcast') {
        console.log('‚ö†Ô∏è Mensagem de status ignorada');
        return;
      }

    // Adiciona logs de depura√ß√£o para verificar o identificador do usu√°rio
    console.log('üîç Verificando usu√°rio JID:', msg.key.remoteJid);
    console.log('üîç Usu√°rios autorizados:', USUARIOS_AUTORIZADOS);

      const isGrupoValido = GRUPOS_PERMITIDOS.includes(msg.key.remoteJid);
    const isUsuarioValido = USUARIOS_AUTORIZADOS.includes(msg.key.remoteJid);
      
    console.log('üîí Verifica√ß√µes Iniciais:');
      console.log('- Grupo v√°lido:', isGrupoValido);
      console.log('- Usu√°rio v√°lido:', isUsuarioValido);
      
      if (!isGrupoValido && !isUsuarioValido) {
      console.log('‚ùå Chat/Usu√°rio n√£o autorizado:', msg.key.remoteJid);
        return;
      }

    console.log('‚úÖ Verifica√ß√µes de autoriza√ß√£o e bot passadas.');
    
    // Verifica se √© uma resposta a uma pergunta anterior (conversa ativa)
    if (temEstadoAtivo && !isUserCommand) {
      console.log('üß† Resposta a pergunta detectada. Processando resposta...');
      await processarResposta(msg.key.remoteJid, texto, isGrupoValido);
        return;
      }

    // Resto da l√≥gica de processamento
    const textoLower = texto.toLowerCase();
    console.log('üö¶ Texto em min√∫sculas:', textoLower);

    if (textoLower === 'ajuda') {
      console.log('üìö Comando "ajuda" detectado. Enviando lista...');
      await enviarMensagemComDelay(msg.key.remoteJid, { text: LISTA_DE_COMANDOS }, isGrupoValido);
      console.log('üìö Lista de comandos enviada. Saindo do processamento.');
        return;
      }

    console.log('üö¶ Comando n√£o √© "ajuda". Prosseguindo...');
    console.log('üß† Verificando se √© comando de estudo...');

      if (pareceSerComandoEstudo(texto)) {
      console.log('üìö Processando comando de estudo:', texto);
      
      // Interpreta√ß√£o do comando (SIMPLIFICADA - pode precisar refinar)
      let comando = null;
      let materia = null;
      if (textoLower.startsWith('estudar') || textoLower.startsWith('ensinar') || textoLower.startsWith('iniciar')) {
          comando = 'estudar';
          // Extrai a mat√©ria ap√≥s o comando
          materia = texto.split(/^(?:estudar|ensinar|iniciar)\s+/i)[1]?.trim(); 
      } else if (textoLower.startsWith('criar plano')) { // Exemplo de outro comando
          comando = 'criar_plano_ensino';
          materia = texto.split(/^(?:criar plano)\s+/i)[1]?.trim();
      }
      // Adicionar mais l√≥gicas if/else if para outros comandos (agendar, anotar, etc.)

      if (!comando || !materia) {
           console.log('‚ö†Ô∏è N√£o foi poss√≠vel extrair comando/mat√©ria v√°lidos da mensagem:', texto);
           await enviarMensagemComDelay(msg.key.remoteJid, { text: "‚ö†Ô∏è N√£o entendi qual comando ou mat√©ria voc√™ quer. Ex: 'ensinar f√≠sica qu√¢ntica'" }, isGrupoValido);
          return;
        }

      console.log(`üí° Comando interpretado: ${comando}, Mat√©ria: ${materia}`);

          let response;
          try {
        console.log(`‚ö° Executando comando: ${comando}`);
        switch (comando) {
          case 'estudar': // 'ensinar' e 'iniciar' tamb√©m caem aqui
            estadoConversa[msg.key.remoteJid] = { nivelAtual: 'iniciante', indicePergunta: 0 };
            await ensinarMateria(materia, msg.key.remoteJid, isGrupoValido);
            return;
          case 'criar_plano_ensino':
            response = await criarPlanoEnsino(materia);
                break;
          // ... Adicionar outros cases conforme necess√°rio ...
            default:
            response = "‚ùå Comando n√£o reconhecido internamente. Use 'ajuda'.";
        }

        // Valida√ß√£o e formata√ß√£o da resposta (l√≥gica existente)
        if (typeof response !== 'string') {
          console.error("Resposta inv√°lida para envio:", response);
          if (typeof response === 'object' && response !== null) {
            if (response.explicacao && response.perguntas) {
              let textoResposta = `üìñ ${response.explicacao}\n\n`;
              textoResposta += `‚ùì Perguntas N√≠vel ${progressoUsuario.nivelAtual}:\n`;
              response.perguntas.forEach((p, index) => {
                textoResposta += `${index + 1}. ${p.pergunta}\n`;
              });
              response = textoResposta;
            } else {
              response = "‚ùå Erro: Resposta interna em formato inesperado.";
            }
          } else {
            response = "‚ùå Erro inesperado no processamento do comando.";
          }
        }

        console.log('üì§ Enviando resposta formatada:', response);
        await enviarMensagemComDelay(msg.key.remoteJid, { text: response }, isGrupoValido);

      } catch (error) {
        console.error('‚ùå Erro ao processar comando espec√≠fico:', error);
        // Envia a mensagem de erro da exce√ß√£o, se houver, caso contr√°rio, uma gen√©rica
        const errorMsg = error.message || "Ocorreu um erro ao processar seu comando. Tente novamente.";
        await enviarMensagemComDelay(msg.key.remoteJid, { 
          text: `‚ùå ${errorMsg}` 
        }, isGrupoValido);
      }

    } else if (temEstadoAtivo) {
      console.log('üîÑ Estado de conversa ativo detectado. Processando resposta...');
      const estado = estadoConversa[msg.key.remoteJid];
      const perguntas = niveis[estado.nivelAtual];
      
      if (!perguntas || perguntas.length === 0) {
        console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
        await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGrupoValido);
        delete estadoConversa[msg.key.remoteJid];
        return;
      }

      // Verifica se j√° respondeu todas as perguntas
      if (estado.indicePergunta >= perguntas.length) {
        console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} j√° foram respondidas`);
        const progresso = verificarProgresso();
        await enviarMensagemComDelay(msg.key.remoteJid, { text: progresso }, isGrupoValido);
        
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        if (progressoUsuario.nivelAtual === estado.nivelAtual) {
          estado.indicePergunta = 0;
          await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGrupoValido);
          await delay(1000);
          await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
        } else {
          // Se avan√ßou, prepara uma nova explica√ß√£o
          const novoNivel = progressoUsuario.nivelAtual;
          try {
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${novoNivel}. Preparando nova explica√ß√£o...` }, isGrupoValido);
            
            const materia = estado.materia;
            const explicacao = await gerarExplicacao(materia, novoNivel);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üìñ ### **${materia} ‚Äì ${novoNivel.toUpperCase()}**\n\n${explicacao}` }, isGrupoValido);
            
            // Atualiza o estado para o novo n√≠vel
            estado.nivelAtual = novoNivel;
            estado.indicePergunta = 0;
            
            // Envia a primeira pergunta do novo n√≠vel
            await delay(2000);
            await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
          } catch (error) {
            console.error(`‚ùå Erro ao avan√ßar para novo n√≠vel:`, error);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${novoNivel}. Por favor, reinicie o estudo.` }, isGrupoValido);
          }
        }
        return;
      }

      const perguntaAtual = perguntas[estado.indicePergunta];
      if (!perguntaAtual) {
        console.error('Pergunta atual n√£o encontrada para:', msg.key.remoteJid);
        return;
      }
      
      console.log('üß† Verificando resposta para:', perguntaAtual.pergunta);
      console.log('üß† Resposta do usu√°rio:', texto);
      console.log('üß† Resposta correta:', perguntaAtual.respostaCorreta);
      
      const resposta = verificarResposta(perguntaAtual, texto);
      await enviarMensagemComDelay(msg.key.remoteJid, { text: resposta }, isGrupoValido);

      // Avan√ßa para a pr√≥xima pergunta independentemente se acertou ou n√£o
      estado.indicePergunta++;
      
      // Verifica se j√° respondeu todas as perguntas do n√≠vel atual para dar o progresso
      // CORRE√á√ÉO: Removendo esta verifica√ß√£o aqui, s√≥ verificar√° quando terminar todas as perguntas
      // O progresso intermedi√°rio ser√° mostrado junto com a pr√≥xima pergunta
      console.log(`üìä Progresso atual: ${progressoUsuario.respostasCorretas}/${progressoUsuario.totalPerguntas} (${(progressoUsuario.respostasCorretas/progressoUsuario.totalPerguntas*100).toFixed(1)}%)`);
      
      // Se ainda tem mais perguntas no n√≠vel atual, envia a pr√≥xima
      if (estado.indicePergunta < perguntas.length) {
        await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
      } else {
        // Se j√° respondeu todas, finaliza o n√≠vel e verifica se pode avan√ßar
        console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} foram respondidas`);
        const progresso = verificarProgresso();
        await enviarMensagemComDelay(msg.key.remoteJid, { text: progresso }, isGrupoValido);
        
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        if (progressoUsuario.nivelAtual === estado.nivelAtual) {
          estado.indicePergunta = 0;
          await enviarMensagemComDelay(msg.key.remoteJid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGrupoValido);
          await delay(1000);
          await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
        } else {
          // Se avan√ßou, prepara uma nova explica√ß√£o
          const novoNivel = progressoUsuario.nivelAtual;
          try {
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${novoNivel}. Preparando nova explica√ß√£o...` }, isGrupoValido);
            
            const materia = estado.materia;
            const explicacao = await gerarExplicacao(materia, novoNivel);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `üìñ ### **${materia} ‚Äì ${novoNivel.toUpperCase()}**\n\n${explicacao}` }, isGrupoValido);
            
            // Atualiza o estado para o novo n√≠vel
            estado.nivelAtual = novoNivel;
            estado.indicePergunta = 0;
            
            // Envia a primeira pergunta do novo n√≠vel
            await delay(2000);
            await enviarProximaPergunta(msg.key.remoteJid, isGrupoValido);
          } catch (error) {
            console.error(`‚ùå Erro ao avan√ßar para novo n√≠vel:`, error);
            await enviarMensagemComDelay(msg.key.remoteJid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${novoNivel}. Por favor, reinicie o estudo.` }, isGrupoValido);
          }
        }
      }
    } else {
      console.log('‚ö†Ô∏è Comando n√£o parece ser de estudo e n√£o h√° estado de conversa ativo:', texto);
    }
  });
}

// Fun√ß√£o para criar um plano de ensino
async function criarPlanoEnsino(materia) {
  try {
    // Chamar LLM para gerar plano (exemplo com DeepSeek)
    const prompt = `Crie um plano de ensino em JSON para "${materia}" com 3 n√≠veis. Inclua t√≥picos e recursos.`;
    let respostaLLM;
    let tentativas = 0;
    const maxTentativas = 5; // Aumentar o n√∫mero de tentativas

    while (tentativas < maxTentativas) {
      try {
        console.time("Tempo de resposta da API"); // Inicia o cron√¥metro para medir o tempo de resposta
        respostaLLM = await axios.post(
          'https://openrouter.ai/api/v1/chat/completions',
          {
            model: 'deepseek/deepseek-chat-v3-0324:free',
            response_format: { type: "json_object" }, // Solicita resposta JSON
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
          },
          {
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
              'HTTP-Referer': 'http://localhost',
              'X-Title': 'Bot de Estudos'
            },
            timeout: 10000 // Mant√©m o timeout de 10 segundos
          }
        );
        console.timeEnd("Tempo de resposta da API"); // Finaliza o cron√¥metro e exibe o tempo de resposta
        break; // Sai do loop se a solicita√ß√£o for bem-sucedida
      } catch (error) {
        console.timeEnd("Tempo de resposta da API"); // Finaliza o cron√¥metro em caso de erro
        tentativas++;
        console.error(`‚ùå Erro ao chamar API (tentativa ${tentativas}):`, error);
        if (error.response?.status === 429) {
          console.error("‚ùå Limite de requisi√ß√µes excedido. Tente novamente mais tarde.");
          return "‚ùå Limite de requisi√ß√µes excedido. Tente novamente mais tarde.";
        }
        if (tentativas >= maxTentativas || (error.response?.status !== 502 && !error.response?.data?.choices?.[0]?.error?.metadata?.raw?.retryable)) {
          console.log("üîÑ Usando interpreta√ß√£o manual para continuar o processamento.");
          return criarPlanoBasico(materia); // Usa interpreta√ß√£o manual para criar um plano b√°sico
        }
        await delay(2000); // Espera 2 segundos antes de tentar novamente
      }
    }

    // Adiciona log para capturar a resposta completa
    console.log("üì• Resposta completa da LLM:", JSON.stringify(respostaLLM.data, null, 2));
    console.log("üì• Tipo de conte√∫do:", respostaLLM.headers['content-type']);

    // Verifica se a resposta √© do tipo esperado
    if (!respostaLLM.headers['content-type'].includes('application/json')) {
      console.error("‚ùå Resposta n√£o √© JSON:", respostaLLM.data);
      return criarPlanoBasico(materia); // Retorna plano b√°sico se a resposta n√£o for JSON
    }

    // Tenta extrair e analisar a parte JSON da resposta
    let plano;
    try {
      const messageContent = respostaLLM.data.choices[0].message.content;
      console.log("üì• Conte√∫do da mensagem:", messageContent);
      const jsonMatch = messageContent.match(/\{[^]*\}/);
      if (!jsonMatch) {
        console.error("‚ùå JSON n√£o encontrado na resposta:", messageContent);
        return criarPlanoBasico(materia); // Retorna plano b√°sico se JSON n√£o for encontrado
      }
      plano = JSON.parse(jsonMatch[0]);
    } catch (jsonError) {
      console.error("‚ùå Erro ao analisar JSON:", jsonError);
      return criarPlanoBasico(materia); // Retorna plano b√°sico se houver erro ao analisar JSON
    }
    
    // Verifica se o plano possui n√≠veis e t√≥picos
    if (!plano.plano_ensino || !plano.plano_ensino.niveis || plano.plano_ensino.niveis.length === 0) {
      return criarPlanoBasico(materia); // Retorna plano b√°sico se a estrutura estiver incompleta
    }

    for (const nivel of plano.plano_ensino.niveis) {
      if (!nivel.topicos || nivel.topicos.length === 0) {
        return criarPlanoBasico(materia); // Retorna plano b√°sico se algum n√≠vel n√£o tiver t√≥picos
      }
    }

    // Registrar no Google Sheets
    const response = await chamarOpenRouter(`Registre o plano de ensino para "${materia}" com os dados: ${JSON.stringify(plano)} e o prazo: ${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()}`, true);

    return `üìò Plano criado! Primeiro t√≥pico: ${plano.plano_ensino.niveis[0].topicos[0]}
Recursos: ${plano.plano_ensino.niveis[0].recursos.join(", ")}`;
  } catch (error) {
    return criarPlanoBasico(materia); // Retorna plano b√°sico em caso de erro geral
  }
}

// Fun√ß√£o para criar um plano b√°sico quando a API falhar
function criarPlanoBasico(materia) {
  console.log("üîÑ Criando plano b√°sico para:", materia);
  return `üìò Plano b√°sico criado para ${materia}. Primeiro t√≥pico: Introdu√ß√£o ao ${materia}`;
}

async function agendarRevisao(materiaId, t√≥pico) {
  const agenda = planilha.getSheetByName("Hist√≥rico");
  agenda.appendRow([
    materiaId,
    `Revis√£o programada: ${t√≥pico}`,
    new Date(Date.now() + NIVEL_APRENDIZADO.BASICO.revisao * 60 * 60 * 1000)
  ]);
}

async function buscarProximoT√≥pico(materiaId) {
  const response = await chamarOpenRouter(`Forne√ßa o pr√≥ximo t√≥pico para "${materiaId}"`, true);
  return response.data;
}

// Fun√ß√£o para gerar um identificador √∫nico
function gerarIdUnico() {
  return 'id-' + Math.random().toString(36).substr(2, 9);
}

async function ensinarMateria(materia, jid, isGroup) {
  console.log(`üìö Iniciando processo de ensinar: ${materia}`);
  if (!materia || materia.trim() === "") {
      return "‚ùå Por favor, especifique a mat√©ria que voc√™ quer aprender. Ex: ensinar hist√≥ria do Brasil";
  }
  
  try {
    // Obter o n√≠vel atual do usu√°rio (ou iniciar como iniciante)
    const nivelAtual = estadoConversa[jid]?.nivelAtual || 'iniciante';
    console.log(`üìä N√≠vel atual do usu√°rio: ${nivelAtual}`);
    
    // Gerar explica√ß√£o apropriada para o n√≠vel atual
    const explicacao = await gerarExplicacao(materia, nivelAtual);
    console.log(`‚úÖ Explica√ß√£o gerada para o n√≠vel: ${nivelAtual}`);
    
    // Gerar perguntas baseadas na explica√ß√£o para o n√≠vel atual
    let perguntasNivel;
    try {
      perguntasNivel = await gerarPerguntas(materia, explicacao, nivelAtual);
      console.log(`‚úÖ Perguntas geradas para o n√≠vel: ${nivelAtual}`);
    } catch (error) {
      console.error(`‚ùå Erro ao gerar perguntas. Usando placeholders:`, error);
      perguntasNivel = await gerarPerguntasPlaceholder(materia, nivelAtual);
    }
    
    // Armazenar perguntas no n√≠vel correspondente
    niveis[nivelAtual] = perguntasNivel;
    
    // Resetar contadores de progresso no in√≠cio do estudo
    progressoUsuario = {
      nivelAtual: nivelAtual,
      respostasCorretas: 0,
      totalPerguntas: 0,
      totalPerguntasDoNivel: perguntasNivel.length
    };
    
    // Inicializar ou atualizar o estado da conversa
    estadoConversa[jid] = { 
      nivelAtual: nivelAtual, 
      indicePergunta: 0,
      materia: materia,
      continuando: true // Marca que esta sess√£o √© uma continua√ß√£o
    };
    
    // Enviar explica√ß√£o e perguntas para o usu√°rio
    let response = `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}\n\n‚ùì Perguntas (N√≠vel ${nivelAtual}):\n`;
    perguntasNivel.forEach((p, index) => {
      response += `${index + 1}. ${p.pergunta}\n`;
    });

    await enviarMensagemComDelay(jid, { text: response }, isGroup);
    console.log(`üì§ Enviada explica√ß√£o e perguntas para o n√≠vel: ${nivelAtual}`);

    // Se estamos iniciando um novo estudo, gerar perguntas para os outros n√≠veis tamb√©m
    // para t√™-las prontas quando o usu√°rio avan√ßar
    if (nivelAtual === 'iniciante' && (!estadoConversa[jid] || !estadoConversa[jid].continuando)) {
      console.log(`üîÑ Gerando perguntas para n√≠veis futuros em segundo plano...`);
      
      // Gerar perguntas para intermedi√°rio (em background)
      gerarExplicacao(materia, 'intermediario').then(explicIntermediario => {
        gerarPerguntas(materia, explicIntermediario, 'intermediario').then(perguntasIntermediario => {
          niveis.intermediario = perguntasIntermediario;
          console.log(`‚úÖ Perguntas para n√≠vel intermedi√°rio armazenadas em background.`);
        }).catch(error => {
          console.error(`‚ùå Erro ao gerar perguntas intermedi√°rias em background:`, error);
          gerarPerguntasPlaceholder(materia, 'intermediario').then(placeholders => {
            niveis.intermediario = placeholders;
          });
        });
      }).catch(error => {
        console.error(`‚ùå Erro ao gerar explica√ß√£o intermedi√°ria em background:`, error);
      });
      
      // Gerar perguntas para avan√ßado (em background)
      gerarExplicacao(materia, 'avancado').then(explicAvancado => {
        gerarPerguntas(materia, explicAvancado, 'avancado').then(perguntasAvancado => {
          niveis.avancado = perguntasAvancado;
          console.log(`‚úÖ Perguntas para n√≠vel avan√ßado armazenadas em background.`);
        }).catch(error => {
          console.error(`‚ùå Erro ao gerar perguntas avan√ßadas em background:`, error);
          gerarPerguntasPlaceholder(materia, 'avancado').then(placeholders => {
            niveis.avancado = placeholders;
          });
        });
      }).catch(error => {
        console.error(`‚ùå Erro ao gerar explica√ß√£o avan√ßada em background:`, error);
      });
    }

  } catch (error) { // Captura erros gerais do processo ensinarMateria
    console.error(`‚ùå Erro geral ao ensinar mat√©ria ${materia}:`, error);
    // Retorna uma mensagem de erro que ser√° enviada ao usu√°rio
    throw new Error(`Erro ao gerar conte√∫do de estudo para ${materia}. ${error.message}`); 
  }
}

// Fun√ß√£o para verificar se a resposta √© uma sigla financeira
function verificarRespostaSigla(respostaUsuario, respostaCorreta) {
  // Normaliza as respostas (remove espa√ßos, converte para mai√∫sculas)
  const userNormalizado = respostaUsuario.toUpperCase().replace(/\s+/g, '');
  const correctNormalizado = respostaCorreta.toUpperCase().replace(/\s+/g, '');
  
  // Lista de siglas financeiras importantes para verifica√ß√£o rigorosa
  const siglas = [
    'CDB', 'CDI', 'LCI', 'LCA', 'LF', 'IPCA', 'SELIC', 'IOF', 'IR', 'PGBL', 
    'VGBL', 'FGTS', 'CVM', 'CETIP', 'FGC', 'B3', 'FII', 'ETF', 'FIA', 'FIM'
  ];
  
  // Verificar quais siglas est√£o presentes na resposta correta
  const siglasEsperadas = siglas.filter(sigla => correctNormalizado.includes(sigla));
  
  // Se n√£o h√° siglas esperadas na resposta correta, retorna true (n√£o precisa verificar)
  if (siglasEsperadas.length === 0) {
    console.log('‚ÑπÔ∏è Sem siglas financeiras para verificar na resposta.');
    return true;
  }
  
  console.log(`üî§ Checando ${siglasEsperadas.length} siglas financeiras na resposta...`);
  
  // Verifica cada sigla encontrada na resposta correta
  for (const sigla of siglasEsperadas) {
    console.log(`üîç Verificando sigla: ${sigla}`);
    
    // Para siglas, exigimos correspond√™ncia exata
    if (!userNormalizado.includes(sigla)) {
      console.log(`‚ùå Sigla ${sigla} n√£o encontrada na resposta do usu√°rio.`);
      return false;
    }
    
    // Se encontrou a sigla no texto do usu√°rio, continua verificando as outras
    console.log(`‚úÖ Sigla ${sigla} encontrada na resposta do usu√°rio.`);
  }
  
  // Se chegou aqui, todas as siglas esperadas foram encontradas
  return true;
}

// Remover a l√≥gica de similaridade
// ... existing code ...
async function verificarResposta(pergunta, respostaUsuario) {
  if (!progressoUsuario) {
    console.error("‚ùå Objeto progressoUsuario n√£o inicializado");
    return "Desculpe, ocorreu um erro ao verificar sua resposta. Por favor, reinicie o estudo.";
  }

  const respostaCorreta = pergunta.respostaCorreta;
  progressoUsuario.totalPerguntas++;
  
  // Verifica se est√° vazio ou muito curto
  if (!respostaUsuario || respostaUsuario.trim().length < 2) {
    return "Resposta muito curta. Por favor, forne√ßa uma resposta mais completa.";
  }
  
  try {
    console.log("ü§ñ Verificando resposta com OpenRouter...")
    console.log("üìù Pergunta:", pergunta.pergunta);
    console.log("üìù Resposta do usu√°rio:", respostaUsuario);
    console.log("üìù Resposta correta:", respostaCorreta);
    
    // Cria um prompt para a API
    const prompt = `Voc√™ √© um assistente educacional preciso que avalia respostas.
    
Pergunta: "${pergunta.pergunta}"
Resposta correta: "${respostaCorreta}"
Resposta do estudante: "${respostaUsuario}"

A resposta do estudante est√° correta considerando o significado e conceito? Avalie se a resposta demonstra compreens√£o do conceito, n√£o apenas correspond√™ncia textual exata.

IMPORTANTE: Se a pergunta envolve siglas financeiras (como CDB, CDI, IPCA, etc.), a resposta do estudante DEVE incluir a sigla correta para ser considerada correta.

D√™ o resultado como "CORRETO" ou "INCORRETO", seguido de uma breve explica√ß√£o de um ou dois pontos sobre por que a resposta est√° correta ou incorreta.

Formato de sa√≠da:
RESULTADO: [CORRETO/INCORRETO]
EXPLICA√á√ÉO: [breve explica√ß√£o]`;

    // Chama a API para verificar a resposta
    const resultadoAPI = await chamarOpenRouter(prompt, false);
    console.log("ü§ñ Resposta da API:", resultadoAPI);
    
    // Extrai o resultado (CORRETO ou INCORRETO)
    const resultado = resultadoAPI.match(/RESULTADO:\s*(CORRETO|INCORRETO)/i);
    const explicacao = resultadoAPI.match(/EXPLICA√á√ÉO:\s*(.+?)(?:\n|$)/is);
    
    const estaCorreto = resultado && resultado[1].toUpperCase() === "CORRETO";
    const textoExplicacao = explicacao ? explicacao[1].trim() : "";
    
    // Atualiza o progresso se estiver correto
    if (estaCorreto) {
      progressoUsuario.respostasCorretas++;
      return `Correto! ‚úÖ ${textoExplicacao}`;
    } else {
      return `Incorreto. ‚ùå ${textoExplicacao}\nA resposta correta seria: ${respostaCorreta}`;
    }
  } catch (error) {
    console.error("‚ùå Erro ao verificar resposta com API:", error);
    return "Erro ao verificar a resposta. Por favor, tente novamente.";
  }
}

// Fun√ß√£o auxiliar para extrair palavras fundamentais
function extrairPalavrasFundamentais(texto) {
  // Divide o texto em palavras
  const palavras = texto.split(' ');
  
  // Identifica palavras longas (substantivos, verbos importantes)
  // e filtra palavras comuns pouco significativas
  const palavrasComuns = ['com', 'que', 'para', 'por', 'dos', 'das', 'uma', 'nas', 'aos', 'seu', 'sua'];
  
  return palavras
    .filter(palavra => palavra.length > 5) // Palavras mais longas s√£o geralmente mais importantes
    .filter(palavra => !palavrasComuns.includes(palavra)); // Remove palavras comuns
}

// Fun√ß√£o para calcular a similaridade entre duas strings
function calcularSimilaridade(str1, str2) {
  const [shorter, longer] = [str1, str2].sort((a, b) => a.length - b.length);
  const longerLength = longer.length;
  if (longerLength === 0) return 1.0;
  return (longerLength - calcularDistanciaLevenshtein(longer, shorter)) / parseFloat(longerLength);
}

// Fun√ß√£o para calcular a dist√¢ncia de Levenshtein
function calcularDistanciaLevenshtein(a, b) {
  const an = a ? a.length : 0;
  const bn = b ? b.length : 0;
  if (an === 0) return bn;
  if (bn === 0) return an;
  const matrix = Array.from({ length: an + 1 }, () => Array(bn + 1).fill(0));
  for (let i = 0; i <= an; i++) matrix[i][0] = i;
  for (let j = 0; j <= bn; j++) matrix[0][j] = j;
  for (let i = 1; i <= an; i++) {
    for (let j = 1; j <= bn; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      );
    }
  }
  return matrix[an][bn];
}

function verificarProgresso() {
  const { respostasCorretas, totalPerguntas, totalPerguntasDoNivel } = progressoUsuario;
  
  // Verifica se totalPerguntas √© zero para evitar NaN
  const percentualAcertos = totalPerguntas > 0 ? (respostasCorretas / totalPerguntas) * 100 : 0;
  
  console.log(`üìä Progresso: ${respostasCorretas}/${totalPerguntas} (${percentualAcertos.toFixed(1)}%)`);

  // Se ainda n√£o respondeu todas as perguntas do n√≠vel, continue no mesmo n√≠vel
  if (totalPerguntas < totalPerguntasDoNivel) {
    return `Progresso atual: ${respostasCorretas}/${totalPerguntas} (${percentualAcertos.toFixed(1)}%) - Responda todas as ${totalPerguntasDoNivel} perguntas para avan√ßar.`;
  }
  
  // S√≥ avan√ßa de n√≠vel ap√≥s responder todas as perguntas e atingir o percentual m√≠nimo
  if (percentualAcertos >= 70 || respostasCorretas >= Math.ceil(totalPerguntasDoNivel * 0.7)) {
    let novoNivel = progressoUsuario.nivelAtual;
    
    if (progressoUsuario.nivelAtual === 'iniciante') {
      novoNivel = 'intermediario';
    } else if (progressoUsuario.nivelAtual === 'intermediario') {
      novoNivel = 'avancado';
    } else {
      return "Parab√©ns! Voc√™ completou todos os n√≠veis.";
    }
    
    // Atualizar n√≠vel e resetar contadores
    progressoUsuario.nivelAtual = novoNivel;
    
    // Ajustar o total de perguntas do novo n√≠vel
    const perguntasNovoNivel = niveis[novoNivel];
    progressoUsuario.totalPerguntasDoNivel = perguntasNovoNivel ? perguntasNovoNivel.length : 5;
    
    progressoUsuario.respostasCorretas = 0;
    progressoUsuario.totalPerguntas = 0;
    
    return `Voc√™ atingiu ${percentualAcertos.toFixed(1)}% de acertos! Avan√ßou para o n√≠vel ${novoNivel}.`;
  }
  
  // Se n√£o atingiu o percentual m√≠nimo, precisa tentar novamente
  progressoUsuario.respostasCorretas = 0;
  progressoUsuario.totalPerguntas = 0;
  return `Voc√™ atingiu ${percentualAcertos.toFixed(1)}% de acertos. Precisa de pelo menos 70% para avan√ßar. Tente novamente!`;
}

async function gerarExplicacao(materia, nivel = 'iniciante') {
  console.log(`ü§ñ Gerando explica√ß√£o din√¢mica para: ${materia} (N√≠vel: ${nivel})`);
  
  let profundidade;
  switch(nivel) {
    case 'intermediario':
      profundidade = "Forne√ßa uma explica√ß√£o de n√≠vel intermedi√°rio, aprofundando nos conceitos. Inclua exemplos pr√°ticos e algumas aplica√ß√µes.";
                break;
    case 'avancado':
      profundidade = "Forne√ßa uma explica√ß√£o avan√ßada e detalhada, abordando aspectos complexos e nuances do tema. Inclua discuss√µes sobre teoria, aplica√ß√µes avan√ßadas e tend√™ncias atuais.";
                break;
    case 'iniciante':
    default:
      profundidade = "Forne√ßa uma explica√ß√£o b√°sica e introdut√≥ria, focando nos conceitos fundamentais e defini√ß√µes essenciais.";
  }
  
  const prompt = `Explique o t√≥pico "${materia}" para um estudante de n√≠vel ${nivel}. ${profundidade} 
  A explica√ß√£o deve ser abrangente o suficiente para que o estudante possa responder a perguntas sobre o tema.
  Estruture a explica√ß√£o em t√≥picos claros e inclua exemplos onde apropriado.`;
  
  try {
    // Tentar obter a explica√ß√£o da API
    const explicacaoTexto = await chamarOpenRouter(prompt, false);
    
    // Verifica√ß√£o de sanidade
    if (!explicacaoTexto || explicacaoTexto.length < 50) { 
      console.log("‚ö†Ô∏è Explica√ß√£o gerada muito curta ou inv√°lida, usando fallback.");
      return gerarExplicacaoFallback(materia, nivel);
    }
    
    return explicacaoTexto;
  } catch (error) {
    console.error(`‚ùå Falha ao gerar explica√ß√£o din√¢mica para ${materia} (N√≠vel: ${nivel}):`, error);
    // Usar explica√ß√£o de fallback em caso de erro na API
    console.log("üîÑ Usando explica√ß√£o de fallback devido a erro na API.");
    return gerarExplicacaoFallback(materia, nivel);
  }
}

async function gerarPerguntas(materia, explicacao, nivel = 'iniciante') {
  console.log(`ü§ñ Gerando perguntas din√¢micas para: ${materia} (N√≠vel: ${nivel})`);
  
  // Resumo da explica√ß√£o para incluir no prompt (limitado para n√£o exceder o contexto)
  const explicacaoResumida = explicacao.length > 500 ? explicacao.substring(0, 500) + "..." : explicacao;
  
  const prompt = `Com base na seguinte explica√ß√£o sobre "${materia}":
  
  ${explicacaoResumida}
  
  Gere 5 perguntas de m√∫ltipla escolha para o n√≠vel "${nivel}". As perguntas devem ser diretamente baseadas no conte√∫do da explica√ß√£o acima.
  
  Para cada pergunta, forne√ßa a pergunta em si ('pergunta') e a resposta correta ('respostaCorreta').
  
  Retorne APENAS um objeto JSON com a seguinte estrutura:
  {
    "perguntas": [
      { "pergunta": "...", "respostaCorreta": "..." },
      // ...mais perguntas
    ]
  }`;

  try {
    let respostaTexto = await chamarOpenRouter(prompt, true); // Espera JSON

    // Limpa poss√≠veis marcadores Markdown antes do parse
    console.log("üìù Limpando resposta da API antes do parse...");
    respostaTexto = respostaTexto.trim();
    if (respostaTexto.startsWith("```json")) {
        respostaTexto = respostaTexto.substring(7, respostaTexto.length - 3).trim();
    } else if (respostaTexto.startsWith("```")) {
        respostaTexto = respostaTexto.substring(3, respostaTexto.length - 3).trim();
    }
    console.log("üìù Resposta limpa:", respostaTexto);

    const perguntasObj = JSON.parse(respostaTexto);

    // Valida√ß√£o da estrutura recebida
    if (!perguntasObj || 
        !Array.isArray(perguntasObj.perguntas) || 
        perguntasObj.perguntas.length < 3 ||
        !perguntasObj.perguntas[0].pergunta || 
        !perguntasObj.perguntas[0].respostaCorreta) {
      console.error("‚ùå Estrutura JSON de perguntas inv√°lida recebida da API:", perguntasObj);
      throw new Error("A API retornou perguntas em formato inv√°lido.");
    }
    
    console.log("‚úÖ Perguntas JSON recebidas e validadas para n√≠vel:", nivel);
    return perguntasObj.perguntas;

  } catch (error) {
    console.error(`‚ùå Falha ao gerar/parsear perguntas din√¢micas para ${materia} (N√≠vel: ${nivel}):`, error);
    throw new Error(`N√£o foi poss√≠vel gerar perguntas para ${materia} via API.`);
  }
}

// Fun√ß√£o para gerar explica√ß√£o de fallback espec√≠ficas para cada mat√©ria
function gerarExplicacaoFallback(materia, nivel = 'iniciante') {
  console.log(`‚ö†Ô∏è Usando explica√ß√£o fallback para ${materia} (n√≠vel ${nivel})`);
  
  const materiaFormatada = materia.toUpperCase().trim();
  
  // Verificar se a mat√©ria cont√©m CDB ou CDI (para casos como "CDB e CDI" ou "CDB/CDI")
  if (materiaFormatada.includes('CDB')) {
    if (nivel === 'iniciante') {
      return `# Certificado de Dep√≥sito Banc√°rio (CDB) - N√≠vel Iniciante

O Certificado de Dep√≥sito Banc√°rio (CDB) √© um investimento de renda fixa emitido por bancos. Funciona como um empr√©stimo que voc√™ faz ao banco, e em troca, recebe juros pelo dinheiro emprestado.

## Caracter√≠sticas principais:
- √â considerado um investimento seguro
- Possui prote√ß√£o do FGC (Fundo Garantidor de Cr√©ditos) at√© R$ 250.000 por CPF e institui√ß√£o financeira
- A rentabilidade √© definida no momento da aplica√ß√£o
- Pode ser prefixado (taxa fixa) ou p√≥s-fixado (atrelado a um √≠ndice como CDI)
- Possui tributa√ß√£o regressiva de Imposto de Renda (de 22,5% a 15%, dependendo do tempo de aplica√ß√£o)

## Para quem √© indicado:
- Investidores iniciantes buscando seguran√ßa
- Pessoas que querem uma alternativa melhor √† poupan√ßa
- Quem busca uma reserva de emerg√™ncia com melhor rendimento`;
    } else if (nivel === 'intermediario') {
      return `# Certificado de Dep√≥sito Banc√°rio (CDB) - N√≠vel Intermedi√°rio

O CDB √© um t√≠tulo de renda fixa emitido por bancos comerciais como forma de capta√ß√£o de recursos. Ao investir em CDB, voc√™ empresta dinheiro ao banco e recebe juros em troca.

## Tipos de CDB:
1. **CDB Prefixado**: A taxa de rentabilidade √© definida no momento da aplica√ß√£o
2. **CDB P√≥s-fixado**: A rentabilidade est√° atrelada a um indexador, geralmente o CDI
3. **CDB H√≠brido**: Combina caracter√≠sticas dos dois anteriores, com parte prefixada e parte p√≥s-fixada

## Tributa√ß√£o:
- Imposto de Renda (tabela regressiva):
  - At√© 180 dias: 22,5%
  - De 181 a 360 dias: 20%
  - De 361 a 720 dias: 17,5%
  - Acima de 720 dias: 15%
- IOF: Incide sobre resgates em menos de 30 dias

## Estrat√©gias de investimento:
- **Escalonamento de vencimentos**: Dividir o capital em CDBs com diferentes prazos
- **Diversifica√ß√£o entre institui√ß√µes**: Distribuir aplica√ß√µes entre diferentes bancos para aumentar a cobertura do FGC
- **Combina√ß√£o com outros investimentos**: Usar CDBs como parte de uma carteira diversificada`;
    } else if (nivel === 'avancado') {
      return `# Certificado de Dep√≥sito Banc√°rio (CDB) - N√≠vel Avan√ßado

O CDB √© um instrumento de capta√ß√£o de recursos dos bancos, oferecendo ao investidor uma remunera√ß√£o pelo capital emprestado √† institui√ß√£o financeira.

## An√°lise aprofundada:

### Precifica√ß√£o e marca√ß√£o a mercado:
- O valor do CDB pode variar antes do vencimento conforme as condi√ß√µes de mercado
- Em caso de resgate antecipado, o t√≠tulo passa pela marca√ß√£o a mercado
- A precifica√ß√£o considera o risco de cr√©dito da institui√ß√£o emissora

### Fatores que influenciam a rentabilidade:
- Rating da institui√ß√£o financeira
- Prazos de vencimento
- Volume de aplica√ß√£o
- Cen√°rio macroecon√¥mico e pol√≠tica monet√°ria

### CDBs estruturados:
- S√£o opera√ß√µes que combinam CDB tradicional com derivativos
- Podem oferecer potencial de rentabilidade maior, mas com maior complexidade e risco
- Geralmente possuem condi√ß√µes espec√≠ficas para rentabilidade

### Estrat√©gias avan√ßadas:
- Opera√ß√µes de arbitragem entre CDBs
- Hedge com outros instrumentos financeiros
- An√°lise de spread de cr√©dito entre diferentes emissores

### Considera√ß√µes tribut√°rias avan√ßadas:
- Impacto do come-cotas em fundos vs. CDBs
- Estrat√©gias de posterga√ß√£o fiscal
- Otimiza√ß√£o tribut√°ria em carteiras diversificadas`;
    }
  } else if (materiaFormatada.includes('CDI')) {
    if (nivel === 'iniciante') {
      return `# Certificado de Dep√≥sito Interbanc√°rio (CDI) - N√≠vel Iniciante

O CDI (Certificado de Dep√≥sito Interbanc√°rio) √© uma taxa de juros utilizada nas opera√ß√µes entre bancos. Em termos simples, √© a taxa que os bancos usam para emprestar dinheiro entre si por um dia.

## Import√¢ncia do CDI:
- Serve como refer√™ncia para diversos investimentos de renda fixa
- Acompanha de perto a taxa Selic (taxa b√°sica de juros da economia)
- √â utilizado para calcular a rentabilidade de v√°rios produtos financeiros

## Como afeta os investimentos:
- Muitos investimentos s√£o remunerados como um percentual do CDI (exemplo: 110% do CDI)
- Quando o CDI sobe, a rentabilidade desses investimentos tamb√©m aumenta
- √â considerado um bom par√¢metro para avaliar se um investimento est√° oferecendo um retorno adequado

## Para o investidor iniciante:
- Ao avaliar um investimento, verifique quanto ele paga em rela√ß√£o ao CDI
- Um investimento que paga 100% do CDI significa que sua rentabilidade ser√° igual √† taxa CDI
- Percentuais acima de 100% do CDI significam que o investimento render√° mais que a taxa`;
    } else if (nivel === 'intermediario') {
      return `# Certificado de Dep√≥sito Interbanc√°rio (CDI) - N√≠vel Intermedi√°rio

O CDI √© uma taxa de juros utilizada nas transa√ß√µes interbanc√°rias, representando o custo dos empr√©stimos de curt√≠ssimo prazo entre institui√ß√µes financeiras.

## Caracter√≠sticas t√©cnicas do CDI:
- √â calculado diariamente pela B3 (antiga CETIP)
- Reflete a m√©dia das taxas praticadas no mercado interbanc√°rio
- Possui alta correla√ß√£o com a taxa Selic, mas n√£o s√£o exatamente iguais
- √â expresso como taxa anual mas calculado diariamente (base 252 dias √∫teis)

## Impacto nos investimentos:
- A maioria dos fundos de renda fixa tem como benchmark o CDI
- Investimentos p√≥s-fixados como CDBs e LCIs/LCAs frequentemente usam o CDI como refer√™ncia
- A rentabilidade real (descontada a infla√ß√£o) varia conforme o patamar do CDI

## Estrat√©gias de investimento baseadas no CDI:
- Em cen√°rios de CDI alto: favorecer investimentos p√≥s-fixados
- Em cen√°rios de CDI baixo: considerar investimentos prefixados ou h√≠bridos
- Utilizar o CDI como refer√™ncia para avaliar o pr√™mio de risco de outros investimentos

## C√°lculo pr√°tico:
Para calcular o rendimento de um investimento a 110% do CDI quando o CDI est√° em 12% ao ano:
- Rendimento = 12% √ó 110% = 13,2% ao ano`;
    } else if (nivel === 'avancado') {
      return `# Certificado de Dep√≥sito Interbanc√°rio (CDI) - N√≠vel Avan√ßado

O CDI √© um instrumento financeiro que representa a taxa m√©dia das opera√ß√µes de empr√©stimos de um dia entre institui√ß√µes banc√°rias. Al√©m de ser um instrumento de capta√ß√£o, o CDI atua como um importante benchmark para o mercado financeiro brasileiro.

## Aspectos t√©cnicos avan√ßados:

### Forma√ß√£o da taxa CDI:
- Processo de apura√ß√£o pela B3 atrav√©s do sistema DI
- C√°lculo baseado na m√©dia ponderada das opera√ß√µes interbanc√°rias
- Rela√ß√£o entre varia√ß√µes no CDI e a pol√≠tica monet√°ria do Banco Central
- Impacto das decis√µes do COPOM sobre a trajet√≥ria da taxa

### CDI e estrutura√ß√£o de produtos financeiros:
- Uso do CDI como ativo subjacente em contratos de derivativos
- Swaps DI x Pr√© e DI x IPCA: forma√ß√£o de pre√ßos e aplica√ß√µes
- Arbitragem entre mercados de juros futuros e CDI
- Estrat√©gias de imuniza√ß√£o de carteiras usando o CDI como refer√™ncia

### Modelagem quantitativa:
- Modelos de interpola√ß√£o de curvas de juros
- C√°lculo de duration e convexidade em pap√©is referenciados em CDI
- Precifica√ß√£o de ativos complexos com base na estrutura a termo do CDI
- An√°lise de sensibilidade de carteiras a varia√ß√µes na curva de CDI

### Aplica√ß√µes em gest√£o de riscos:
- VaR (Value at Risk) de carteiras expostas ao CDI
- Stress testing considerando diferentes cen√°rios para o CDI
- Estrat√©gias de hedge para riscos de taxa de juros`;
    }
  }
  
  return `Desculpe, n√£o tenho uma explica√ß√£o pr√©-definida para ${materia} no n√≠vel ${nivel}. Vamos prosseguir com as perguntas dispon√≠veis.`;
}

// Fun√ß√£o para gerar perguntas placeholder em caso de falha da API
async function gerarPerguntasPlaceholder(materia, nivel = 'iniciante') {
    console.warn(`‚ö†Ô∏è Usando perguntas placeholder para: ${materia} (N√≠vel: ${nivel})`);
    
    const materiaFormatada = materia.toUpperCase().trim();
    
    // Perguntas espec√≠ficas para CDB e CDI
    if (materiaFormatada.includes('CDB') || materiaFormatada.includes('CDI')) {
        if (nivel === 'iniciante') {
          return [
            { 
              pergunta: "O que significa a sigla CDB?", 
              respostaCorreta: "Certificado de Dep√≥sito Banc√°rio" 
            },
            { 
              pergunta: "Qual √© a principal fun√ß√£o do CDB?", 
              respostaCorreta: "Captar recursos para os bancos, funcionando como um empr√©stimo do investidor para a institui√ß√£o financeira" 
            },
            { 
              pergunta: "O que o CDI representa no contexto de investimentos?", 
              respostaCorreta: "√â uma taxa de refer√™ncia para investimentos de renda fixa, baseada nas opera√ß√µes entre bancos" 
            },
            { 
              pergunta: "Se um CDB rende 110% do CDI e o CDI acumula 10% em um ano, quanto receber√° um investidor que aplicou R$ 1.000?", 
              respostaCorreta: "R$ 1.110" 
            },
            { 
              pergunta: "At√© que valor o CDB √© garantido pelo FGC (Fundo Garantidor de Cr√©ditos)?", 
              respostaCorreta: "At√© R$ 250 mil por CPF e institui√ß√£o financeira" 
            }
          ];
        } else if (nivel === 'intermediario') {
          return [
            { 
              pergunta: "Quais s√£o os tr√™s tipos principais de CDBs quanto √† forma de remunera√ß√£o?", 
              respostaCorreta: "Prefixados, p√≥s-fixados e h√≠bridos" 
            },
            { 
              pergunta: "Como funciona a tributa√ß√£o de Imposto de Renda sobre o CDB para um investimento de 2 anos?", 
              respostaCorreta: "Al√≠quota de 15% sobre o rendimento, conforme a tabela regressiva" 
            },
            { 
              pergunta: "Qual √© a rela√ß√£o entre a Taxa Selic e o CDI?", 
              respostaCorreta: "O CDI normalmente acompanha de perto a Taxa Selic, sendo um pouco menor" 
            },
            { 
              pergunta: "O que acontece com o rendimento de um CDB prefixado se a taxa Selic subir durante o per√≠odo de investimento?", 
              respostaCorreta: "O rendimento nominal permanece o mesmo, mas o rendimento real pode ficar menos atrativo comparado a novos investimentos" 
            },
            { 
              pergunta: "Al√©m do Imposto de Renda, que outro imposto pode incidir sobre resgates de CDB?", 
              respostaCorreta: "IOF (Imposto sobre Opera√ß√µes Financeiras) para resgates antes de 30 dias" 
            }
          ];
        } else if (nivel === 'avancado') {
          return [
            { 
              pergunta: "Como a curva de juros do CDI influencia a precifica√ß√£o de CDBs de longo prazo?", 
              respostaCorreta: "A curva de juros do CDI representa as taxas futuras esperadas, permitindo que os bancos precifiquem CDBs de longo prazo de acordo com as expectativas do mercado para as taxas de juros" 
            },
            { 
              pergunta: "O que √© a estrat√©gia 'ladder' (escada) de CDBs e quais seus benef√≠cios?", 
              respostaCorreta: "√â a distribui√ß√£o de recursos em CDBs com diferentes vencimentos, permitindo reinvestimentos peri√≥dicos a novas taxas e melhor gerenciamento de liquidez" 
            },
            { 
              pergunta: "Como as regras de Basileia III afetam a oferta e precifica√ß√£o de CDBs pelos bancos?", 
              respostaCorreta: "As regras de Basileia III exigem √≠ndices de capital mais elevados, o que pode levar alguns bancos a oferecer CDBs com taxas mais atrativas para captar recursos e melhorar seus indicadores de liquidez" 
            },
            { 
              pergunta: "Explique como funciona a marca√ß√£o a mercado (MtM) em CDBs prefixados e seu impacto para o investidor em caso de resgate antecipado.", 
              respostaCorreta: "Na marca√ß√£o a mercado, CDBs prefixados s√£o reavaliados diariamente conforme as taxas de mercado. Se as taxas subirem ap√≥s a compra, o valor de mercado cai, gerando preju√≠zo em resgates antecipados. Se as taxas ca√≠rem, o valor de mercado sobe, gerando ganho adicional" 
            },
            { 
              pergunta: "Qual a diferen√ßa entre uma opera√ß√£o compromissada e um CDB do ponto de vista da capta√ß√£o banc√°ria?", 
              respostaCorreta: "Nas opera√ß√µes compromissadas, o banco vende t√≠tulos com compromisso de recompra, oferecendo lastro; no CDB, o banco emite um t√≠tulo de d√≠vida sem lastro espec√≠fico. As compromissadas t√™m prazos geralmente mais curtos e tratamento cont√°bil diferente nas institui√ß√µes financeiras" 
            }
          ];
        }
    }
    
    // Para outras mat√©rias, usamos perguntas gen√©ricas
    let perguntas;
    switch(nivel) {
      case 'intermediario':
        perguntas = [
          { pergunta: `Explique os princ√≠pios fundamentais de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 1" },
          { pergunta: `Como ${materia} se relaciona com outras √°reas? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 2" },
          { pergunta: `Quais s√£o as principais teorias em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 3" },
          { pergunta: `Desafios encontrados no estudo de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 4" },
          { pergunta: `M√©todos utilizados para pesquisa em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder interm. 5" }
        ];
                break;
      case 'avancado':
        perguntas = [
          { pergunta: `Problemas complexos em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 1" },
          { pergunta: `Estado atual da pesquisa em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 2" },
          { pergunta: `Tend√™ncias futuras em ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 3" },
          { pergunta: `Casos avan√ßados de aplica√ß√£o de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 4" },
          { pergunta: `Integra√ß√£o de ${materia} com tecnologias emergentes? (Placeholder)`, respostaCorreta: "Resposta placeholder avan√ß. 5" }
        ];
                break;
      case 'iniciante':
              default:
        perguntas = [
          { pergunta: `O que √© ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 1" },
          { pergunta: `Quando surgiu ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 2" },
          { pergunta: `Quais s√£o os principais conceitos de ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 3" },
          { pergunta: `Como ${materia} √© aplicado no dia a dia? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 4" },
          { pergunta: `Quais s√£o os benef√≠cios de estudar ${materia}? (Placeholder)`, respostaCorreta: "Resposta placeholder iniciante 5" }
        ];
    }
    
    return perguntas;
}

async function enviarProximaPergunta(jid, isGroup) {
  const estado = estadoConversa[jid];
  if (!estado) {
    console.error('Estado da conversa n√£o encontrado para:', jid);
    return;
  }

  const perguntas = niveis[estado.nivelAtual];
  if (!perguntas || perguntas.length === 0) {
    console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
    await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGroup);
    delete estadoConversa[jid]; // Limpa o estado para evitar problemas
    return;
  }

  if (estado.indicePergunta >= perguntas.length) {
    console.error('√çndice de pergunta fora dos limites:', estado.indicePergunta, 'de', perguntas.length);
    await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar a pr√≥xima pergunta. Por favor, inicie um novo estudo.' }, isGroup);
    delete estadoConversa[jid]; // Limpa o estado para evitar problemas
    return;
  }

  const perguntaAtual = perguntas[estado.indicePergunta];
  if (!perguntaAtual) {
    console.error('Pergunta atual n√£o encontrada para:', jid);
    return;
  }

  await enviarMensagemComDelay(jid, { text: `‚ùì Pergunta: ${perguntaAtual.pergunta}` }, isGroup);
}

// Modificar para evitar m√∫ltiplas transi√ß√µes de n√≠vel ou mensagens duplicadas
async function processarResposta(jid, texto, isGroup) {
  // Evita processamento concorrente de respostas
  if (processandoRespostaFlag) {
    console.log("‚ö†Ô∏è J√° existe um processamento de resposta em andamento. Ignorando.");
    return;
  }
  
  processandoRespostaFlag = true;
  
  try {
    const estado = estadoConversa[jid];
    if (!estado) {
      console.error('Estado da conversa n√£o encontrado para:', jid);
      processandoRespostaFlag = false;
      return;
    }
    
    const perguntas = niveis[estado.nivelAtual];
    if (!perguntas || perguntas.length === 0) {
      console.error('Perguntas n√£o encontradas para o n√≠vel:', estado.nivelAtual);
      await enviarMensagemComDelay(jid, { text: 'Houve um problema ao recuperar as perguntas. Por favor, inicie um novo estudo.' }, isGroup);
      delete estadoConversa[jid];
      processandoRespostaFlag = false;
      return;
    }

    if (estado.indicePergunta >= perguntas.length) {
      console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} j√° foram respondidas`);
      const progresso = verificarProgresso();
      await enviarMensagemComDelay(jid, { text: progresso }, isGroup);
      
      // Verifica se avan√ßou de n√≠vel
      const nivelAnterior = estado.nivelAtual;
      const nivelAtual = progressoUsuario.nivelAtual;
      
      if (nivelAtual !== nivelAnterior) {
        // Evita m√∫ltiplas tentativas de enviar explica√ß√µes
        if (envioExplicacaoEmAndamento[jid]) {
          console.log(`‚ö†Ô∏è J√° existe um envio de explica√ß√£o em andamento para ${jid}. Ignorando.`);
          processandoRespostaFlag = false;
          return;
        }
        
        envioExplicacaoEmAndamento[jid] = true;
        
        try {
          await enviarMensagemComDelay(jid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${nivelAtual}. Preparando nova explica√ß√£o...` }, isGroup);
          
          const materia = estado.materia;
          let explicacao;
          
          try {
            // Tenta obter explica√ß√£o via API apenas uma vez
            explicacao = await gerarExplicacao(materia, nivelAtual);
          } catch (error) {
            console.error(`‚ùå Erro ao gerar explica√ß√£o para novo n√≠vel:`, error);
            explicacao = gerarExplicacaoFallback(materia, nivelAtual);
          }
          
          await enviarMensagemComDelay(jid, { text: `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}` }, isGroup);
          
          // Atualiza o estado para o novo n√≠vel
          estado.nivelAtual = nivelAtual;
          estado.indicePergunta = 0;
          
          // Prepara perguntas para o novo n√≠vel, se necess√°rio
          if (!niveis[nivelAtual] || niveis[nivelAtual].length === 0) {
            try {
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            } catch (error) {
              console.error(`‚ùå Erro ao gerar perguntas para novo n√≠vel:`, error);
              // Use perguntas placeholders como fallback
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            }
          }
          
          // Envia a primeira pergunta do novo n√≠vel ap√≥s delay
          await delay(2000);
          await enviarProximaPergunta(jid, isGroup);
    } catch (error) {
          console.error(`‚ùå Erro ao processar avan√ßo de n√≠vel:`, error);
          await enviarMensagemComDelay(jid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${nivelAtual}. Por favor, reinicie o estudo.` }, isGroup);
          delete estadoConversa[jid];
        } finally {
          // Remove o flag de envio em andamento
          delete envioExplicacaoEmAndamento[jid];
        }
      } else {
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        estado.indicePergunta = 0;
        await enviarMensagemComDelay(jid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGroup);
        await delay(1000);
        await enviarProximaPergunta(jid, isGroup);
      }
      
      processandoRespostaFlag = false;
      return;
    }

    const perguntaAtual = perguntas[estado.indicePergunta];
    if (!perguntaAtual) {
      console.error('Pergunta atual n√£o encontrada para:', jid);
      processandoRespostaFlag = false;
      return;
    }

    console.log('üß† Verificando resposta para:', perguntaAtual.pergunta);
    console.log('üß† Resposta do usu√°rio:', texto);
    console.log('üß† Resposta correta:', perguntaAtual.respostaCorreta);
    
    // Enviar mensagem de feedback indicando que a resposta est√° sendo processada
    await enviarMensagemComDelay(jid, { text: "‚è≥ Analisando sua resposta..." }, isGroup);
    
    // Agora verificarResposta √© uma fun√ß√£o ass√≠ncrona
    const resposta = await verificarResposta(perguntaAtual, texto);
    await enviarMensagemComDelay(jid, { text: resposta }, isGroup);

    // Avan√ßa para a pr√≥xima pergunta independentemente se acertou ou n√£o
    estado.indicePergunta++;
    
    // Se ainda tem mais perguntas no n√≠vel atual, envia a pr√≥xima
    if (estado.indicePergunta < perguntas.length) {
      await enviarProximaPergunta(jid, isGroup);
    } else {
      // Se j√° respondeu todas, finaliza o n√≠vel e verifica se pode avan√ßar
      console.log(`‚úÖ Todas as perguntas do n√≠vel ${estado.nivelAtual} foram respondidas`);
      const progresso = verificarProgresso();
      await enviarMensagemComDelay(jid, { text: progresso }, isGroup);
      
      // Verifica se avan√ßou de n√≠vel
      const nivelAnterior = estado.nivelAtual;
      const nivelAtual = progressoUsuario.nivelAtual;
      
      if (nivelAtual !== nivelAnterior) {
        // Evita m√∫ltiplas tentativas de enviar explica√ß√µes
        if (envioExplicacaoEmAndamento[jid]) {
          console.log(`‚ö†Ô∏è J√° existe um envio de explica√ß√£o em andamento para ${jid}. Ignorando.`);
          processandoRespostaFlag = false;
          return;
        }
        
        envioExplicacaoEmAndamento[jid] = true;
        
        try {
          await enviarMensagemComDelay(jid, { text: `üéâ Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${nivelAtual}. Preparando nova explica√ß√£o...` }, isGroup);
          
          const materia = estado.materia;
          let explicacao;
          
          try {
            // Tenta obter explica√ß√£o via API apenas uma vez
            explicacao = await gerarExplicacao(materia, nivelAtual);
          } catch (error) {
            console.error(`‚ùå Erro ao gerar explica√ß√£o para novo n√≠vel:`, error);
            explicacao = gerarExplicacaoFallback(materia, nivelAtual);
          }
          
          await enviarMensagemComDelay(jid, { text: `üìñ ### **${materia} ‚Äì ${nivelAtual.toUpperCase()}**\n\n${explicacao}` }, isGroup);
          
          // Atualiza o estado para o novo n√≠vel
          estado.nivelAtual = nivelAtual;
          estado.indicePergunta = 0;
          
          // Prepara perguntas para o novo n√≠vel, se necess√°rio
          if (!niveis[nivelAtual] || niveis[nivelAtual].length === 0) {
            try {
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            } catch (error) {
              console.error(`‚ùå Erro ao gerar perguntas para novo n√≠vel:`, error);
              // Use perguntas placeholders como fallback
              niveis[nivelAtual] = await gerarPerguntasPlaceholder(materia, nivelAtual);
            }
          }
          
          // Envia a primeira pergunta do novo n√≠vel ap√≥s delay
          await delay(2000);
          await enviarProximaPergunta(jid, isGroup);
        } catch (error) {
          console.error(`‚ùå Erro ao processar avan√ßo de n√≠vel:`, error);
          await enviarMensagemComDelay(jid, { text: `Houve um problema ao avan√ßar para o n√≠vel ${nivelAtual}. Por favor, reinicie o estudo.` }, isGroup);
          delete estadoConversa[jid];
        } finally {
          // Remove o flag de envio em andamento
          delete envioExplicacaoEmAndamento[jid];
        }
      } else {
        // Se n√£o avan√ßou de n√≠vel, reinicia as perguntas
        estado.indicePergunta = 0;
        await enviarMensagemComDelay(jid, { text: 'Vamos recome√ßar as perguntas deste n√≠vel para voc√™ melhorar seu desempenho.' }, isGroup);
        await delay(1000);
        await enviarProximaPergunta(jid, isGroup);
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao processar resposta:', error);
  } finally {
    processandoRespostaFlag = false;
  }
}

// Inicia o servidor
iniciarConexaoWhatsApp().then(() => {
  app.listen(3000, () => console.log("Servidor rodando na porta 3000!"));
});

// Exportar vari√°veis e fun√ß√µes importantes para testes e integra√ß√£o
module.exports = {
  OPENROUTER_API_KEY,
  chamarOpenRouter,
  gerarExplicacaoFallback,
  gerarPerguntasPlaceholder
};
